<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>Rigol1000z.commands API documentation</title>
<meta name="description" content="This module contains definitions for command menus of the Rigol1000z series of oscilloscopes." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Rigol1000z.commands</code></h1>
</header>
<section id="section-intro">
<p>This module contains definitions for command menus of the Rigol1000z series of oscilloscopes.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module contains definitions for command menus of the Rigol1000z series of oscilloscopes.
&#34;&#34;&#34;

import os
import numpy as _np
import tqdm as _tqdm
import pyvisa as _visa
from Rigol1000z.rigol1000zcommandmenu import Rigol1000zCommandMenu
from Rigol1000z.constants import *
from typing import List, Union, Iterable


class Channel(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    Complete
    &#34;&#34;&#34;

    def __init__(self, visa_resource: _visa.Resource, channel: int, idn: str = None):
        super().__init__(visa_resource, idn)
        self._channel = channel

        self.cmd_hierarchy_str = f&#34;:chan{self._channel}&#34;

    @property
    def channel(self):
        return self._channel

    @property
    def name(self):
        return f&#34;CHAN{self.channel}&#34;

    @property
    def bw_limit_20mhz(self):
        resp = self.visa_ask(&#39;:bwl?&#39;)
        return resp == &#34;20M&#34;

    @bw_limit_20mhz.setter
    def bw_limit_20mhz(self, val: bool):
        self.visa_write(f&#39;:bwl {&#34;20M&#34; if val else &#34;OFF&#34;}&#39;)

    @property
    def coupling(self):
        return self.visa_ask(&#39;:coup?&#39;)

    @coupling.setter
    def coupling(self, val):
        val = val.upper()
        assert val in (&#39;AC&#39;, &#39;DC&#39;, &#39;GND&#39;)
        self.visa_write(f&#39;:coup {val}&#39;)

    @property
    def enabled(self):
        return bool(int(self.visa_ask(&#39;:disp?&#39;)))

    @enabled.setter
    def enabled(self, val: bool):
        self.visa_write(f&#39;:disp {int(val is True)}&#39;)

    @property
    def invert(self):
        return bool(int(self.visa_ask(&#39;:inv?&#39;)))

    @invert.setter
    def invert(self, val: bool):
        self.visa_write(f&#39;:inv {int(val is True)}&#39;)

    @property
    def offset_v(self) -&gt; float:
        return float(self.visa_ask(&#39;:off?&#39;))

    @offset_v.setter
    def offset_v(self, val: float):
        &#34;&#34;&#34;
        Related to the current vertical scale and probe ratio

        When the probe ratio is 1X:
            vertical scale≥500mV/div: -100V to +100V
            vertical scale&lt;500mV/div: -2V to +2V
        When the probe ratio is 10X:
            vertical scale≥5V/div: -1000V to +1000V
            vertical scale&lt;5V/div: -20V to +20V

        :param val: The offset voltage to set (volts)
        &#34;&#34;&#34;
        # todo: check probe ratio and vertical scale to ensure valid value

        assert -1000. &lt;= val &lt;= 1000.
        self.visa_write(f&#39;:off {val:.4e}&#39;)

    @property
    def range_v(self) -&gt; float:
        return float(self.visa_ask(&#39;:rang?&#39;))

    @range_v.setter
    def range_v(self, val: float):
        assert 8e-3 &lt;= val &lt;= 800.
        self.visa_write(f&#39;:rang {val:.4e}&#39;)

    @property
    def calibration_delay(self) -&gt; float:
        &#34;&#34;&#34;
        Query the delay calibration time of the specified channel to calibrate the zero offset
        of the corresponding channel. The default unit is s.

        :return:
        &#34;&#34;&#34;
        return float(self.visa_ask(&#39;:tcal?&#39;))

    @calibration_delay.setter
    def calibration_delay(self, val: float):
        &#34;&#34;&#34;
        Can only be set to the specific values in the specified step. If the parameter you
        sent is not one of the specific values, the parameter will be set to the nearest specific
        values automatically

        :param val:
        :return:
        &#34;&#34;&#34;
        # todo: add addition rules to detect and ensure that channel can&#39;t leave the specified delay range

        assert -100e-9 &lt;= val &lt;= 100e-9
        self.visa_write(f&#39;:tcal {val:.4e}&#39;)

    @property
    def scale_v(self) -&gt; float:
        return float(self.visa_ask(&#39;:scal?&#39;))

    @scale_v.setter
    def scale_v(self, val: float):
        probe_ratio = self.probe_ratio
        assert 1e-3 * probe_ratio &lt;= val &lt;= 10. * probe_ratio
        self.visa_write(f&#39;:scal {val:.4e}&#39;)

    @property
    def probe_ratio(self) -&gt; float:
        return float(self.visa_ask(&#39;:prob?&#39;))

    @probe_ratio.setter
    def probe_ratio(self, val: float):
        assert val in {0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000}
        self.visa_write(f&#39;:prob {val:.4e}&#39;)

    @property
    def units(self) -&gt; str:
        return self.visa_ask(&#39;:unit?&#39;)

    @units.setter
    def units(self, val: str):
        val = val.lower()
        assert val in (&#39;volt&#39;, &#39;watt&#39;, &#39;amp&#39;, &#39;unkn&#39;)
        self.visa_write(f&#39;:unit {val}&#39;)

    @property
    def vernier(self):
        return bool(int(self.visa_ask(&#39;:vern?&#39;)))

    @vernier.setter
    def vernier(self, val: bool):
        self.visa_write(f&#39;:vern {int(val is True)}&#39;)


class Acquire(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    Complete
    &#34;&#34;&#34;
    cmd_hierarchy_str = &#34;:acq&#34;

    def __init__(self, visa_resource: _visa.Resource, channels: List[Channel], idn: str = None):
        super().__init__(visa_resource, idn)
        self._linked_channels = channels

    @property
    def averages(self):
        &#34;&#34;&#34;
        Query the number of averages under the average acquisition mode.
        2^n (n is an integer from 1 to 10)
        :return: an integer between 2 and 1024.
        &#34;&#34;&#34;
        return int(self.visa_ask(&#39;:aver?&#39;))

    @averages.setter
    def averages(self, val):
        &#34;&#34;&#34;
        Set the number of averages under the average acquisition mode.

        :param val:
        :return:
        &#34;&#34;&#34;
        assert val in [2 ** n for n in range(1, 11)]
        self.visa_write(f&#39;:aver {int(val)}&#39;)

    @property
    def memory_depth(self) -&gt; int:
        &#34;&#34;&#34;
        Query the memory depth of the oscilloscope (namely the number of waveform
        points that can be stored in a single trigger sample). The default unit is pts (points).

        Auto mode is indicated with a -1 returned

        :return:
        &#34;&#34;&#34;
        md = self.visa_ask(&#39;:mdep?&#39;)
        return int(md) if md != &#39;AUTO&#39; else -1

    # todo: requires access to channels
    @memory_depth.setter
    def memory_depth(self, val: int):
        &#34;&#34;&#34;
        #todo: figure out if this command requires a run command before memory depth can be written

        Auto mode is indicated with a -1

        :param val: The number of points to acquire
        :return:
        &#34;&#34;&#34;

        num_enabled_chans = sum(1 if c.enabled else 0 for c in self._linked_channels)

        val = int(val) if val != -1 else &#39;AUTO&#39;

        if num_enabled_chans == 1:
            assert val in (&#39;AUTO&#39;, 12000, 120000, 1200000, 12000000, 24000000)
        elif num_enabled_chans == 2:
            assert val in (&#39;AUTO&#39;, 6000, 60000, 600000, 6000000, 12000000)
        elif num_enabled_chans in (3, 4):
            assert val in (&#39;AUTO&#39;, 3000, 30000, 300000, 3000000, 6000000)

        # todo: set to run mode if required
        self.visa_write(f&#39;:mdep {val}&#39;)

    @property
    def mode(self):
        return self.visa_ask(&#39;:type?&#39;)

    @mode.setter
    def mode(self, val: str):
        assert val in {EAcquireMode.Normal, EAcquireMode.Averages, EAcquireMode.HighResolution, EAcquireMode.Peak}
        self.visa_write(f&#39;:type {val}&#39;)

    @property
    def sampling_rate(self):
        &#34;&#34;&#34;
        Sample rate is the sample frequency of the oscilloscope, namely the waveform points sampled per second.

        The following equation describes the relationship among memory depth, sample rate, and waveform length:
            Memory Depth = Sample Rate x Waveform Length

        Wherein:
            Memory Depth can be set using the :ACQuire:MDEPth command
            Waveform Length is the product of:
                The horizontal timebase (set by the :TIMebase[:MAIN]:SCALe command)
                The number of the horizontal scales (12 for DS1000Z).

        :return: A float with units Sa/s
        &#34;&#34;&#34;
        return float(self.visa_ask(&#39;:srat?&#39;))


class Calibrate(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    Complete
    &#34;&#34;&#34;

    cmd_hierarchy_str = &#34;:cal&#34;

    def set_auto_calibration(self, state: bool = True):
        self.visa_write(f&#34;:{&#39;star&#39; if state else &#39;quit&#39;}&#34;)


# incomplete
class Cursor(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:curs&#34;


# incomplete
class Decoder(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:dec&#34;


class Display(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    Complete
    &#34;&#34;&#34;
    cmd_hierarchy_str = &#34;:disp&#34;

    def clear(self):
        return self.visa_write(&#39;:cle&#39;)

    # def data
    # this is currently implemented in the primary Rigol1000z class

    @property
    def mode(self):
        return self.visa_ask(&#39;:type?&#39;)

    @mode.setter
    def mode(self, val: str):
        assert val in {EDisplayMode.Vectors, EDisplayMode.Dots}
        self.visa_write(f&#39;:type {val}&#39;)

    @property
    def persistence_time(self):
        return self.visa_ask(&#39;:grad:time?&#39;)

    @persistence_time.setter
    def persistence_time(self, val: Union[float, str]):
        &#34;&#34;&#34;
         MIN: set the persistence time to its minimum to view the waveform changing in high refresh rate.

         Specific Values: set the persistence time to one of the values listed above to observe
        glitch that changes relatively slowly or glitch with low occurrence probability.

         INFinite: in this mode, the oscilloscope displays the newly acquired waveform
        without clearing the waveform formerly acquired. It can be used to measure noise
        and jitter as well as capture incidental events.

        :param val:
        :return:
        &#34;&#34;&#34;
        assert val in {&#34;MIN&#34;, 0.1, 0.2, 0.5, 1, 5, 10, &#34;INF&#34;}
        self.visa_write(f&#39;:grad:time {val}&#39;)

    @property
    def brightness(self):
        &#34;&#34;&#34;
        Query the screen brightness

        :return: A float between 0 and 1
        &#34;&#34;&#34;
        return float(self.visa_ask(&#39;:WBR?&#39;) / 100.0)

    @brightness.setter
    def brightness(self, val: float):
        &#34;&#34;&#34;
        Set the screen brightness

        :param val: A float between 0 and 1
        :return:
        &#34;&#34;&#34;
        assert 0.0 &lt;= val &lt;= 1.0
        self.visa_write(f&#39;:WBR {int(val * 100)}&#39;)

    @property
    def grid(self):
        &#34;&#34;&#34;
        Set or query the grid type of screen display
        :return:
        &#34;&#34;&#34;
        return self.visa_ask(&#39;:GRID?&#39;)

    @grid.setter
    def grid(self, val: float):
        assert val in {EDisplayGrid.Full, EDisplayGrid.Half, EDisplayGrid.NoGrid}
        self.visa_write(f&#39;:GRID {val}&#39;)

    @property
    def grid_brightness(self):
        &#34;&#34;&#34;
        Query the grid brightness

        :return: A float between 0 and 1
        &#34;&#34;&#34;
        return float(self.visa_ask(&#39;:GBR?&#39;) / 100.0)

    @grid_brightness.setter
    def grid_brightness(self, val: float):
        &#34;&#34;&#34;
        Set the grid brightness

        :param val: A float between 0 and 1
        :return:
        &#34;&#34;&#34;
        assert 0.0 &lt;= val &lt;= 1.0
        self.visa_write(f&#39;:GBR {int(val * 100)}&#39;)


class EventTable(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    Complete
    &#34;&#34;&#34;

    def __init__(self, visa_resource: _visa.Resource, etable_num: int):
        super().__init__(visa_resource)
        assert 1 &lt;= etable_num &lt;= 2
        self._etable_num = etable_num

        self.cmd_hierarchy_str = f&#34;:etab{self._etable_num}&#34;

    @property
    def enabled(self) -&gt; bool:
        &#34;&#34;&#34;
        Query the status of the decoding event table.
        :return: Boolean state of the event table
        &#34;&#34;&#34;
        # todo: query decoder&lt;n&gt;:display to ensure command is valid
        return bool(int(self.visa_ask(&#39;:disp?&#39;)))

    @enabled.setter
    def enabled(self, val: bool):
        &#34;&#34;&#34;
        Turn on or off the decoding event table.
        :param val: Boolean state to set the event table to
        :return:
        &#34;&#34;&#34;

        self.visa_write(f&#39;:disp {1 if val else 0}&#39;)

    @property
    def display_format(self) -&gt; bool:
        return bool(int(self.visa_ask(&#39;:form?&#39;)))

    @display_format.setter
    def display_format(self, val: str):
        assert val in {EEventtableFormat.Hex, EEventtableFormat.Ascii, EEventtableFormat.Decimal}
        self.visa_write(f&#39;:form {val}&#39;)

    @property
    def view(self) -&gt; str:
        return self.visa_ask(&#39;:view?&#39;)

    @view.setter
    def view(self, val: str):
        assert val in {EEventtableViewFormat.Package, EEventtableViewFormat.Detail, EEventtableViewFormat.Payload}
        self.visa_write(f&#39;:view {val}&#39;)

    @property
    def column(self) -&gt; int:
        &#34;&#34;&#34;
        Query the current column of the event table.
        :return:
        &#34;&#34;&#34;
        return int(self.visa_ask(&#39;:col?&#39;))

    @column.setter
    def column(self, val: int):
        &#34;&#34;&#34;
        Set the current column of the event table.

         When different decoder is selected (:DECoder&lt;n&gt;:MODE), the range of &lt;col&gt;
        differs.

        Parallel decoding: DATA
        RS232 decoding: TX|RX
        I2C decoding: DATA
        SPI decoding: MISO|MOSI

         If the TX or RX channel source in RS232 decoding or the MISO or MOSI channel
        source in SPI decoding is set to OFF, &lt;col&gt; cannot be set to the corresponding
        parameter.

        :param val:
        :return:
        &#34;&#34;&#34;

        self.visa_write(f&#39;:col {val}&#39;)

    @property
    def row(self) -&gt; int:
        &#34;&#34;&#34;
        The query returns the current row in integer. If the current even table is empty, the
        query returns 0.

        :return:
        &#34;&#34;&#34;

        return self.visa_ask(&#39;:row?&#39;)

    @row.setter
    def row(self, val: int):
        &#34;&#34;&#34;
        val must be 1 to the maximum number of rows of the current event table
        :param val:
        :return:
        &#34;&#34;&#34;
        # todo: figure out how many rows are in the event table

        self.visa_write(f&#39;:row {val}&#39;)

    @property
    def reverse_sorted(self) -&gt; bool:
        &#34;&#34;&#34;
        Query the display type of the decoding results in the event table.
        :return:
        &#34;&#34;&#34;
        return &#34;DESC&#34; == self.visa_ask(&#39;:sort?&#39;)

    @reverse_sorted.setter
    def reverse_sorted(self, val: bool):
        &#34;&#34;&#34;
        Set the display type of the decoding results in the event table.
        :param val:
        :return:
        &#34;&#34;&#34;
        self.visa_write(f&#39;:sort {&#34;DESC&#34; if val else &#34;ASC&#34;}&#39;)

    def get_data(self) -&gt; any:
        # todo: test and expand this when I have test data to work with
        return self.visa_ask(&#39;:data?&#39;)


# incomplete
class Function(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:func&#34;


class IEEE488(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    Complete
    &#34;&#34;&#34;
    cmd_hierarchy_str = &#34;*&#34;

    def clear_event_registers(self) -&gt; None:
        &#34;&#34;&#34;
        Clear all the event registers and clear the error queue.
        &#34;&#34;&#34;
        self.visa_ask(&#34;cls&#34;)

    @property
    def event_register_enable_mask(self) -&gt; int:
        &#34;&#34;&#34;
        Query the enable register for the standard event status register set.
        &#34;&#34;&#34;
        return int(self.visa_ask(&#34;ese?&#34;))

    @event_register_enable_mask.setter
    def event_register_enable_mask(self, val: int):
        &#34;&#34;&#34;
        Set the enable register for the standard event status register set.
        &#34;&#34;&#34;
        assert 0 &lt;= val &lt; 256
        self.visa_write(f&#34;ese {val}&#34;)

    def query_and_clear_event_register(self) -&gt; int:
        &#34;&#34;&#34;
        Query and clear the event register for the standard event status register.
        &#34;&#34;&#34;
        return int(self.visa_ask(&#34;esr?&#34;))

    @property
    def id_string(self) -&gt; str:
        return self.visa_ask(&#39;idn?&#39;)

    @property
    def operation_complete(self) -&gt; bool:
        return bool(int(self.visa_ask(&#39;opc?&#39;)))

    def reset(self) -&gt; None:
        &#34;&#34;&#34;
        Restore the instrument to the default state.
        &#34;&#34;&#34;
        print(&#34;Reset can take several seconds to complete&#34;)
        old_timeout = self.visa_resource.timeout
        self.visa_resource.timeout = None
        self.visa_write(&#34;rst&#34;)
        wait_for_resp = self.operation_complete  # Wait for queued response before moving onto next command
        self.visa_resource.timeout = old_timeout
        print(&#34;Reset complete&#34;)

    @property
    def status_register_enable_mask(self) -&gt; int:
        &#34;&#34;&#34;
        Query the enable register for the status byte register set.
        &#34;&#34;&#34;
        return int(self.visa_ask(&#34;sre?&#34;))

    @status_register_enable_mask.setter
    def status_register_enable_mask(self, val: int):
        &#34;&#34;&#34;
        Set the enable register for the status byte register set.
        &#34;&#34;&#34;
        assert 0 &lt;= val &lt; 256
        self.visa_write(f&#34;sre {val}&#34;)

    def query_and_clear_status_register(self) -&gt; int:
        &#34;&#34;&#34;
        Query the event register for the status byte register.
        The value of the status byte register is set to 0 after this command is executed.
        &#34;&#34;&#34;
        return int(self.visa_ask(&#34;stb?&#34;))

    def self_test(self) -&gt; int:
        &#34;&#34;&#34;
        Perform a self-test and then return the self-test results
        &#34;&#34;&#34;
        return int(self.visa_ask(&#34;tst?&#34;))

    def wait_until_command_completion(self) -&gt; int:
        &#34;&#34;&#34;
        Wait for the operation to finish.
        The subsequent command can only be carried out after the
        current command has been executed.
        &#34;&#34;&#34;
        return int(self.visa_ask(&#34;wai&#34;))


# incomplete
class LA(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    The :LA commands are used to perform the related operations on the digital channels. These commands
    are only applicable to DS1000Z Plus with the MSO upgrade option.
    &#34;&#34;&#34;
    # todo: write this command menu
    cmd_hierarchy_str = &#34;:la&#34;


# incomplete
class LAN(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:lan&#34;
    # todo: write this command menu


# incomplete
class Math(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:math&#34;
    # todo: write this command menu


# incomplete
class Mask(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    The :MASK commands are used to set and query the pass/fail test parameters.
    &#34;&#34;&#34;
    cmd_hierarchy_str = &#34;:mask&#34;
    # todo: write this command menu


class MeasureCounter(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    Complete
    &#34;&#34;&#34;
    cmd_hierarchy_str = &#34;:meas:coun&#34;

    @property
    def source(self) -&gt; str:
        &#34;&#34;&#34;
        Query the source of the frequency counter, or disable the frequency counter.
        :return: string identifying counter measurement source
        &#34;&#34;&#34;
        return self.visa_ask(f&#39;:sour?&#39;)

    @source.setter
    def source(self, val: str):
        &#34;&#34;&#34;
        Set the source of the frequency counter, or disable the frequency counter.

        :param val: The counter source to select
        :return: None
        &#34;&#34;&#34;

        # Plus models support digital channels
        if self.osc_model in {ScopeModel.DS1104Z_S_Plus, ScopeModel.DS1074Z_S_Plus,
                              ScopeModel.DS1104Z_Plus, ScopeModel.DS1074Z_Plus}:
            assert val in {*sources_analog, *sources_digital}
        else:
            assert val in sources_analog

        self.visa_write(f&#39;:sour {val}&#39;)

    @property
    def value(self) -&gt; float:
        &#34;&#34;&#34;
        Query the measurement result of the frequency counter. The default unit is Hz.
        :return:
        &#34;&#34;&#34;
        return float(self.visa_ask(f&#39;:val?&#39;))


class MeasureSetup(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    Complete
    &#34;&#34;&#34;
    cmd_hierarchy_str = &#34;:meas:set&#34;

    @property
    def max(self) -&gt; float:
        &#34;&#34;&#34;
        Query the upper limit of the threshold (expressed in the ratio of amplitude) in
        time, delay, and phase measurements.

        :return:
        &#34;&#34;&#34;
        return float(round(self.visa_ask(f&#39;:max?&#39;))) / 100.0

    @max.setter
    def max(self, val: float):
        &#34;&#34;&#34;
        Set the upper limit of the threshold (expressed in the ratio of amplitude) in
        time, delay, and phase measurements.

        :return:
        &#34;&#34;&#34;
        assert 0.07 &lt;= val &lt;= 0.95
        self.visa_write(f&#39;:max {round(val * 100.0)}&#39;)

    @property
    def mid(self) -&gt; float:
        &#34;&#34;&#34;
        Query the middle point of the threshold (expressed in the percentage of amplitude)
        in time, delay, and phase measurements.

        :return:
        &#34;&#34;&#34;
        return float(round(self.visa_ask(f&#39;:mid?&#39;))) / 100.0

    @max.setter
    def mid(self, val: float):
        &#34;&#34;&#34;
        Set the middle point of the threshold (expressed in the percentage of amplitude)
        in time, delay, and phase measurements.

        :return:
        &#34;&#34;&#34;
        assert 0.06 &lt;= val &lt;= 0.94
        self.visa_write(f&#39;:mid {round(val * 100.0)}&#39;)

    @property
    def min(self) -&gt; float:
        &#34;&#34;&#34;
        Query the lower limit of the threshold (expressed in the percentage of amplitude) in
        time, delay, and phase measurements.

        :return:
        &#34;&#34;&#34;
        return float(round(self.visa_ask(f&#39;:mid?&#39;))) / 100.0

    @max.setter
    def min(self, val: float):
        &#34;&#34;&#34;
        Set the lower limit of the threshold (expressed in the percentage of amplitude) in
        time, delay, and phase measurements.

        :return:
        &#34;&#34;&#34;
        assert 0.05 &lt;= val &lt;= 0.93
        self.visa_write(f&#39;:mid {round(val * 100.0)}&#39;)

    @property
    def phase_source_a(self) -&gt; str:
        &#34;&#34;&#34;
        Query source A of Phase 1→2 (rising edge) and Phase 1→2 (falling edge) measurements.
        :return:
        &#34;&#34;&#34;
        return str(self.visa_ask(f&#39;:psa?&#39;))

    @phase_source_a.setter
    def phase_source_a(self, val: str):
        &#34;&#34;&#34;
        Set source A of Phase (rising edge) 1→2 and Phase (falling edge) 1→2 measurements.
        :param val: The source to set the phase source to
        :return:
        &#34;&#34;&#34;
        # Plus models support digital channels
        if self.osc_model in {ScopeModel.DS1104Z_S_Plus, ScopeModel.DS1074Z_S_Plus,
                              ScopeModel.DS1104Z_Plus, ScopeModel.DS1074Z_Plus}:
            assert val in {*sources_analog, *sources_digital}
        else:
            assert val in sources_analog

        self.visa_write(f&#39;:psa {val}&#39;)

    @property
    def phase_source_b(self) -&gt; str:
        &#34;&#34;&#34;
        Query source B of Phase 1→2 (rising edge) and Phase 1→2 (falling edge) measurements.
        :return:
        &#34;&#34;&#34;
        return str(self.visa_ask(f&#39;:psb?&#39;))

    @phase_source_b.setter
    def phase_source_b(self, val: str):
        &#34;&#34;&#34;
        Set source B of Phase (rising edge) 1→2 and Phase (falling edge) 1→2 measurements.
        :param val: The source to set the phase source to
        :return:
        &#34;&#34;&#34;
        # Plus models support digital channels
        if self.osc_model in {ScopeModel.DS1104Z_S_Plus, ScopeModel.DS1074Z_S_Plus,
                              ScopeModel.DS1104Z_Plus, ScopeModel.DS1074Z_Plus}:
            assert val in {*sources_analog, *sources_digital}
        else:
            assert val in sources_analog

        self.visa_write(f&#39;:psb {val}&#39;)

    @property
    def delay_source_a(self) -&gt; str:
        &#34;&#34;&#34;
        Query source A of Delay 1→2 (rising edge) and Delay 1→2 (falling edge) measurements.

        :return:
        &#34;&#34;&#34;
        return str(self.visa_ask(f&#39;:dsa?&#39;))

    @delay_source_a.setter
    def delay_source_a(self, val: str):
        &#34;&#34;&#34;
        Set source A of Delay 1→2 (rising edge) and Delay 1→2 (falling edge) measurements.

        :param val:
        :return:
        &#34;&#34;&#34;

        # Plus models support digital channels
        if self.osc_model in {ScopeModel.DS1104Z_S_Plus, ScopeModel.DS1074Z_S_Plus,
                              ScopeModel.DS1104Z_Plus, ScopeModel.DS1074Z_Plus}:
            assert val in {*sources_analog, *sources_digital}
        else:
            assert val in sources_analog

        self.visa_write(f&#39;:dsa {val}&#39;)

    @property
    def delay_source_b(self) -&gt; str:
        &#34;&#34;&#34;
        Query source B of Delay 1→2 (rising edge) and Delay 1→2 (falling edge) measurements.

        :return:
        &#34;&#34;&#34;
        return str(self.visa_ask(f&#39;:dsb?&#39;))

    @delay_source_b.setter
    def delay_source_b(self, val: str):
        &#34;&#34;&#34;
        Set source B of Delay 1→2 (rising edge) and Delay 1→2 (falling edge) measurements.

        :param val:
        :return:
        &#34;&#34;&#34;

        # Plus models support digital channels
        if self.osc_model in {ScopeModel.DS1104Z_S_Plus, ScopeModel.DS1074Z_S_Plus,
                              ScopeModel.DS1104Z_Plus, ScopeModel.DS1074Z_Plus}:
            assert val in {*sources_analog, *sources_digital}
        else:
            assert val in sources_analog

        self.visa_write(f&#39;:dsb {val}&#39;)


class MeasurementStatisticItem(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    Enable the statistic function of any waveform parameter of the specified source,
    or query the statistic result of any waveform parameter of the specified source.

    This class was written to simply the logic of this function as there are many rules.
    All sources must be given when a query is called (no default args)
    &#34;&#34;&#34;
    cmd_hierarchy_str = &#34;:meas:stat:item&#34;

    def _statistic_item_write(self, item, source) -&gt; None:
        self.visa_write(f&#34; {item},{source}&#34;)

    def _statistic_item_query(self, stat_measurement_type, item, source) -&gt; float:
        &#34;&#34;&#34;
        Ensures that the statistic type is valid then builds and calls the visa query

        :param stat_measurement_type:
        :param item:
        :param source:
        :return:
        &#34;&#34;&#34;
        assert stat_measurement_type in {
            EMeasurementStatisticItemType.Maximum, EMeasurementStatisticItemType.Minimum,
            EMeasurementStatisticItemType.Current,
            EMeasurementStatisticItemType.Average,
            EMeasurementStatisticItemType.Deviation
        }
        return float(self.visa_ask(f&#34;? {stat_measurement_type},{item},{source}&#34;))

    # region single source commands

    # Voltage Maximum
    def get_voltage_max(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltageMax,
            source
        )

    def set_voltage_max(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltageMax,
            source
        )

    # Voltage Minimum
    def get_voltage_min(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltageMin,
            source
        )

    def set_voltage_min(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltageMin,
            source
        )

    # Voltage peak to peak
    def get_voltage_peak_to_peak(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltagePeakToPeak,
            source
        )

    def set_voltage_peak_to_peak(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltagePeakToPeak,
            source
        )

    # Voltage Top
    def get_voltage_top(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltageTop,
            source
        )

    def set_voltage_top(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltageTop,
            source
        )

    # Voltage Base
    def get_voltage_base(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltageBase,
            source
        )

    def set_voltage_base(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltageBase,
            source
        )

    # Voltage Amplitude
    def get_voltage_amp(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltageAmplitude,
            source
        )

    def set_voltage_amp(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltageAmplitude,
            source
        )

    # Voltage Average
    def get_voltage_average(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltageAverage,
            source
        )

    def set_voltage_average(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltageAverage,
            source
        )

    # Voltage RMS
    def get_voltage_rms(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltageRMS,
            source
        )

    def set_voltage_rms(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltageRMS,
            source
        )

    # Voltage Overshoot
    def get_voltage_overshoot(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltageOvershoot,
            source
        )

    def set_voltage_overshoot(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltageOvershoot,
            source
        )

    # Area
    def get_area(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.Area,
            source
        )

    def set_area(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.Area,
            source
        )

    # Period Area
    def get_period_area(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.AreaPeriod,
            source
        )

    def set_period_area(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.AreaPeriod,
            source
        )

    # Preshoot
    def get_preshoot(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltagePreshoot,
            source
        )

    def set_preshoot(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltagePreshoot,
            source
        )

    # period
    def get_period(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.Period,
            source
        )

    def set_period(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.Period,
            source
        )

    # frequency
    def get_frequency(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.Frequency,
            source
        )

    def set_frequency(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.Frequency,
            source
        )

    # rise time
    def get_rise_time(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.RiseTime,
            source
        )

    def set_rise_time(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.RiseTime,
            source
        )

    # fall time
    def get_fall_time(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.FallTime,
            source
        )

    def set_fall_time(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.FallTime,
            source
        )

    # width positive
    def get_width_positive(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.WidthPositive,
            source
        )

    def set_width_positive(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.WidthPositive,
            source
        )

    # width negative
    def get_width_negative(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.WidthNegative,
            source
        )

    def set_width_negative(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.WidthNegative,
            source
        )

    # duty positive
    def get_duty_positive(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.DutyPositive,
            source
        )

    def set_duty_positive(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.DutyPositive,
            source
        )

    # duty negative
    def get_duty_negative(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.DutyNegative,
            source
        )

    def set_duty_negative(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.DutyNegative,
            source
        )

    # time_voltage_max
    def get_time_voltage_max(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.TVMax,
            source
        )

    def set_time_voltage_max(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.TVMin,
            source
        )

    # time_voltage_min
    def get_time_voltage_min(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.TVMin,
            source
        )

    def set_time_voltage_min(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.TVMin,
            source
        )

    # Slew rate max
    def get_slew_rate_positive(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.SlewRatePositive,
            source
        )

    def set_slew_rate_positive(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.SlewRatePositive,
            source
        )

    # Slew rate min
    def get_slew_rate_negative(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.SlewRateNegative,
            source
        )

    def set_slew_rate_negative(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.SlewRateNegative,
            source
        )

    # Upper Voltage
    def get_voltage_upper(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltageUpper,
            source
        )

    def set_voltage_upper(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltageUpper,
            source
        )

    # Middle Voltage
    def get_voltage_mid(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltageMid,
            source
        )

    def set_voltage_mid(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltageMid,
            source
        )

    # Lower Voltage
    def get_voltage_lower(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltageLower,
            source
        )

    def set_voltage_lower(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltageLower,
            source
        )

    # Variance
    def get_variance(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.Variance,
            source
        )

    def set_variance(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.Variance,
            source
        )

    # Variance
    def get_voltage_rms_period(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VRmsPeriod,
            source
        )

    def set_voltage_rms_period(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VRmsPeriod,
            source
        )

    # Pulses Positive
    def get_pules_positive(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.PulsesPositive,
            source
        )

    def set_pules_positive(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.PulsesPositive,
            source
        )

    # Pulses Negative
    def get_pules_negative(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.PulsesPositive,
            source
        )

    def set_pules_negative(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.PulsesPositive,
            source
        )

    # Edges Positive
    def get_edges_positive(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.EdgesPositive,
            source
        )

    def set_edges_positive(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.EdgesPositive,
            source
        )

    # Edges Negative
    def get_edges_negative(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.EdgesNegative,
            source
        )

    def set_edges_negative(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.EdgesNegative,
            source
        )

    # endregion

    # region double source commands
    # Rise Delay
    def get_rise_delay(self, source_1: str, source_2: str, stat_measurement_type: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.DelayRise,
            f&#34;{source_1},{source_2}&#34;
        )

    def set_rise_delay(self, source_1: str, source_2: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_write(
            EMeasureItem.DelayRise,
            f&#34;{source_1},{source_2}&#34;
        )

    # Fall Delay
    def get_fall_delay(self, source_1: str, source_2: str, stat_measurement_type: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.DelayFall,
            f&#34;{source_1},{source_2}&#34;
        )

    def set_fall_delay(self, source_1: str, source_2: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_write(
            EMeasureItem.DelayFall,
            f&#34;{source_1},{source_2}&#34;
        )

    # Rise Phase
    def get_rise_phase(self, source_1: str, source_2: str, stat_measurement_type: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.PhaseRise,
            f&#34;{source_1},{source_2}&#34;
        )

    def set_rise_phase(self, source_1: str, source_2: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_write(
            EMeasureItem.PhaseRise,
            f&#34;{source_1},{source_2}&#34;
        )

    # Fall Phase
    def get_fall_phase(self, source_1: str, source_2: str, stat_measurement_type: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.PhaseFall,
            f&#34;{source_1},{source_2}&#34;
        )

    def set_fall_phase(self, source_1: str, source_2: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_write(
            EMeasureItem.PhaseFall,
            f&#34;{source_1},{source_2}&#34;
        )

    # endregion


class MeasurementStatistic(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:meas:stat&#34;

    def __init__(self, visa_resource: _visa.Resource, idn: str):
        super().__init__(visa_resource, idn)
        self.item = MeasurementStatisticItem(visa_resource, idn)

    @property
    def enabled(self) -&gt; bool:
        &#34;&#34;&#34;
        Query the status of the statistic function.
        :return:
        &#34;&#34;&#34;
        return bool(int(self.visa_ask(f&#39;:disp?&#39;)))

    @enabled.setter
    def enabled(self, val: bool):
        &#34;&#34;&#34;
        Enable or disable the statistic function.
        :param val:
        :return:
        &#34;&#34;&#34;
        self.visa_write(f&#39;:disp {1 if val else 0}&#39;)

    @property
    def mode(self) -&gt; str:
        &#34;&#34;&#34;
         DIFFerence:
            The statistic results contain the current value, average value, standard deviation, and counts.

         EXTRemum:
            The statistic results contain the current value, average value, minimum, and maximum.

        :return:
        &#34;&#34;&#34;
        return self.visa_ask(f&#39;:mode?&#39;)

    @mode.setter
    def mode(self, val: str):
        &#34;&#34;&#34;
         DIFFerence:
            The statistic results contain the current value, average value, standard deviation, and counts.

         EXTRemum:
            The statistic results contain the current value, average value, minimum, and maximum.

         Sending the :MEASure:STATistic:DISPlay command can enable the statistic function.
        When the statistic function is enabled, the oscilloscope makes statistic and displays
        the statistic results of at most 5 measurement items that are turned on last.
        :return:
        &#34;&#34;&#34;

        assert val in {EMeasureStatisticMode.Difference, EMeasureStatisticMode.Extremum}
        self.visa_write(f&#39;:mode {val}&#39;)

    def reset(self) -&gt; None:
        &#34;&#34;&#34;
        Clear the history data and make statistic again.
        :return:
        &#34;&#34;&#34;
        self.visa_write(&#39;:res&#39;)

    def item(self):
        pass
        # todo: what the fuck is item (pg 145)


class MeasurementItem(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    Measure any waveform parameter of the specified source,
    or query the measurement result of any waveform parameter of the specified source.

    This class was written to simply the logic of this function as there are many rules.
    All sources must be given when a query is called (no default args)
    &#34;&#34;&#34;
    cmd_hierarchy_str = &#34;:meas:item&#34;

    def _item_write(self, item, source) -&gt; None:
        self.visa_write(f&#34; {item},{source}&#34;)

    def _item_query(self, item, source) -&gt; float:
        &#34;&#34;&#34;
        Ensures that the statistic type is valid then builds and calls the visa query

        :param item:
        :param source:
        :return:
        &#34;&#34;&#34;

        return float(self.visa_ask(f&#34;? {item},{source}&#34;))

    # region single source commands

    # Voltage Maximum
    def get_voltage_max(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltageMax,
            source
        )

    def set_voltage_max(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltageMax,
            source
        )

    # Voltage Minimum
    def get_voltage_min(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltageMin,
            source
        )

    def set_voltage_min(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltageMin,
            source
        )

    # Voltage peak to peak
    def get_voltage_peak_to_peak(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltagePeakToPeak,
            source
        )

    def set_voltage_peak_to_peak(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltagePeakToPeak,
            source
        )

    # Voltage Top
    def get_voltage_top(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltageTop,
            source
        )

    def set_voltage_top(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltageTop,
            source
        )

    # Voltage Base
    def get_voltage_base(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltageBase,
            source
        )

    def set_voltage_base(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltageBase,
            source
        )

    # Voltage Amplitude
    def get_voltage_amp(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltageAmplitude,
            source
        )

    def set_voltage_amp(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltageAmplitude,
            source
        )

    # Voltage Average
    def get_voltage_average(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltageAverage,
            source
        )

    def set_voltage_average(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltageAverage,
            source
        )

    # Voltage RMS
    def get_voltage_rms(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltageRMS,
            source
        )

    def set_voltage_rms(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltageRMS,
            source
        )

    # Voltage Overshoot
    def get_voltage_overshoot(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltageOvershoot,
            source
        )

    def set_voltage_overshoot(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltageOvershoot,
            source
        )

    # Area
    def get_area(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.Area,
            source
        )

    def set_area(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.Area,
            source
        )

    # Period Area
    def get_period_area(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.AreaPeriod,
            source
        )

    def set_period_area(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.AreaPeriod,
            source
        )

    # Preshoot
    def get_preshoot(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltagePreshoot,
            source
        )

    def set_preshoot(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltagePreshoot,
            source
        )

    # period
    def get_period(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.Period,
            source
        )

    def set_period(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.Period,
            source
        )

    # frequency
    def get_frequency(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.Frequency,
            source
        )

    def set_frequency(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.Frequency,
            source
        )

    # rise time
    def get_rise_time(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.RiseTime,
            source
        )

    def set_rise_time(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.RiseTime,
            source
        )

    # fall time
    def get_fall_time(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.FallTime,
            source
        )

    def set_fall_time(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.FallTime,
            source
        )

    # width positive
    def get_width_positive(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.WidthPositive,
            source
        )

    def set_width_positive(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.WidthPositive,
            source
        )

    # width negative
    def get_width_negative(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.WidthNegative,
            source
        )

    def set_width_negative(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.WidthNegative,
            source
        )

    # duty positive
    def get_duty_positive(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.DutyPositive,
            source
        )

    def set_duty_positive(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.DutyPositive,
            source
        )

    # duty negative
    def get_duty_negative(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.DutyNegative,
            source
        )

    def set_duty_negative(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.DutyNegative,
            source
        )

    # time_voltage_max
    def get_time_voltage_max(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.TVMax,
            source
        )

    def set_time_voltage_max(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.TVMin,
            source
        )

    # time_voltage_min
    def get_time_voltage_min(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.TVMin,
            source
        )

    def set_time_voltage_min(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.TVMin,
            source
        )

    # Slew rate max
    def get_slew_rate_positive(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.SlewRatePositive,
            source
        )

    def set_slew_rate_positive(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.SlewRatePositive,
            source
        )

    # Slew rate min
    def get_slew_rate_negative(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.SlewRateNegative,
            source
        )

    def set_slew_rate_negative(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.SlewRateNegative,
            source
        )

    # Upper Voltage
    def get_voltage_upper(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltageUpper,
            source
        )

    def set_voltage_upper(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltageUpper,
            source
        )

    # Middle Voltage
    def get_voltage_mid(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltageMid,
            source
        )

    def set_voltage_mid(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltageMid,
            source
        )

    # Lower Voltage
    def get_voltage_lower(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltageLower,
            source
        )

    def set_voltage_lower(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltageLower,
            source
        )

    # Variance
    def get_variance(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.Variance,
            source
        )

    def set_variance(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.Variance,
            source
        )

    # Variance
    def get_voltage_rms_period(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VRmsPeriod,
            source
        )

    def set_voltage_rms_period(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VRmsPeriod,
            source
        )

    # Pulses Positive
    def get_pules_positive(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.PulsesPositive,
            source
        )

    def set_pules_positive(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.PulsesPositive,
            source
        )

    # Pulses Negative
    def get_pules_negative(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.PulsesPositive,
            source
        )

    def set_pules_negative(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.PulsesPositive,
            source
        )

    # Edges Positive
    def get_edges_positive(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.EdgesPositive,
            source
        )

    def set_edges_positive(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.EdgesPositive,
            source
        )

    # Edges Negative
    def get_edges_negative(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.EdgesNegative,
            source
        )

    def set_edges_negative(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.EdgesNegative,
            source
        )

    # endregion

    # region double source commands
    # Rise Delay
    def get_rise_delay(self, source_1: str, source_2: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.DelayRise,
            f&#34;{source_1},{source_2}&#34;
        )

    def set_rise_delay(self, source_1: str, source_2: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_write(
            EMeasureItem.DelayRise,
            f&#34;{source_1},{source_2}&#34;
        )

    # Fall Delay
    def get_fall_delay(self, source_1: str, source_2: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.DelayFall,
            f&#34;{source_1},{source_2}&#34;
        )

    def set_fall_delay(self, source_1: str, source_2: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_write(
            EMeasureItem.DelayFall,
            f&#34;{source_1},{source_2}&#34;
        )

    # Rise Phase
    def get_rise_phase(self, source_1: str, source_2: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.PhaseRise,
            f&#34;{source_1},{source_2}&#34;
        )

    def set_rise_phase(self, source_1: str, source_2: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_write(
            EMeasureItem.PhaseRise,
            f&#34;{source_1},{source_2}&#34;
        )

    # Fall Phase
    def get_fall_phase(self, source_1: str, source_2: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.PhaseFall,
            f&#34;{source_1},{source_2}&#34;
        )

    def set_fall_phase(self, source_1: str, source_2: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_write(
            EMeasureItem.PhaseFall,
            f&#34;{source_1},{source_2}&#34;
        )

    # endregion


class Measure(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    DS1000Z supports the auto measurement of the following 37 waveform parameters and provides the
    statistic function for the measurement results.

    In additional, you can use the frequency counter to make more precise frequency measurement.

    Measure commands are used to set and query the measurement parameters.
    &#34;&#34;&#34;
    cmd_hierarchy_str = &#34;:meas&#34;

    def __init__(self, visa_resource: _visa.Resource, idn: str = None):
        super().__init__(visa_resource, idn)

        self.counter = MeasureCounter(visa_resource, idn)
        self.setup = MeasureSetup(visa_resource, idn)
        self.statistic = MeasurementStatistic(visa_resource, idn)
        self.item = MeasurementItem(visa_resource, idn)

    @property
    def source(self) -&gt; str:
        &#34;&#34;&#34;
        Query the source of the current measurement parameter.
        :return: string identifying current measurement source
        &#34;&#34;&#34;
        return self.visa_ask(f&#39;:sour?&#39;)

    @source.setter
    def source(self, val: str):
        &#34;&#34;&#34;
        Set the source of the current measurement parameter.

        :param val: The source to select
        :return: None
        &#34;&#34;&#34;

        # Plus models support digital channels
        if self.osc_model in {ScopeModel.DS1104Z_S_Plus, ScopeModel.DS1074Z_S_Plus,
                              ScopeModel.DS1104Z_Plus, ScopeModel.DS1074Z_Plus}:
            assert val in {*sources_analog, *sources_digital, *sources_math}
        else:
            assert val in {*sources_analog, *sources_math}

        self.visa_write(f&#39;:sour {val}&#39;)

    def clear(self, item_num: int):
        &#34;&#34;&#34;
        Clear one or all of the last five measurement items enabled
        Pass the item number to disable that item
        Pass -1 to disable all

        :param item_num: Item to clear
        :return:
        &#34;&#34;&#34;
        assert item_num in {-1, 1, 2, 3, 4, 5}
        if item_num == -1:
            self.visa_write(f&#39;:cle ALL&#39;)
        else:
            self.visa_write(f&#39;:cle ITEM{item_num}&#39;)

    def recover(self, item_num: int):
        &#34;&#34;&#34;
        Recover the measurement item which has been cleared
        Pass the item number to recover that item
        Pass -1 to recover all

        :param item_num: Item to recover
        :return:
        &#34;&#34;&#34;
        assert item_num in {-1, 1, 2, 3, 4, 5}
        if item_num == -1:
            self.visa_write(f&#39;:rec ALL&#39;)
        else:
            self.visa_write(f&#39;:rec ITEM{item_num}&#39;)

    @property
    def all_measurement(self) -&gt; bool:
        return bool(int(self.visa_ask(f&#39;:adis?&#39;)))

    @all_measurement.setter
    def all_measurement(self, val: bool):
        &#34;&#34;&#34;
        Enable or disable the all measurement function, or query the status of the all measurement function

         The all measurement function can measure the following 29 parameters of the source at the same time:
            Voltage Parameters:
                Vmax, Vmin, Vpp, Vtop, Vbase, Vamp,
                Vupper, Vmid, Vlower, Vavg, Vrms,
                Overshoot, Preshoot, Period Vrms, and Variance

            Time Parameters:
                Period, Frequency, Rise Time, Fall Time, +Width, -Width, +Duty, -Duty, tVmax, and tVmin

            Other Parameters:
                +Rate, -Rate, Area, and Period Area.

         The all measurement function can measure CH1, CH2, CH3, CH4, and the MATH
        channel at the same time. You can send the :MEASure:AMSource command to set
        the source of the all measurement function.

        :param val:
        :return:
        &#34;&#34;&#34;
        self.visa_write(f&#39;:adis {1 if val else 0}&#39;)

    @property
    def all_measurement_source(self) -&gt; List[str]:
        &#34;&#34;&#34;
        Query the source(s) of the all measurement function.
        :return:
        &#34;&#34;&#34;
        return str(self.visa_ask(f&#39;:ams?&#39;)).split(&#34;,&#34;)

    @all_measurement_source.setter
    def all_measurement_source(self, val: Iterable[str]):
        &#34;&#34;&#34;
        Set the source(s) of the all measurement function.
        :param val:
        :return:
        &#34;&#34;&#34;
        self.visa_write(f&#39;:ams {&#34;,&#34;.join(val)}&#39;)


# incomplete
class Reference(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:ref&#34;


# incomplete
class Source(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:sour&#34;


# incomplete
class Storage(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:stor&#34;


# incomplete
class System(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:syst&#34;


# incomplete
class Trace(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:trac&#34;


class TimebaseDelay(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:tim:del&#34;

    @property
    def enabled(self) -&gt; bool:
        return bool(int(self.visa_ask(&#39;:enab?&#39;)))

    @enabled.setter
    def enabled(self, val: bool):
        self.visa_write(f&#39;:enab {val}&#39;)

    @property
    def offset(self) -&gt; float:
        &#34;&#34;&#34;
        Query the delayed timebase offset. The default unit is s.

        :return:
        &#34;&#34;&#34;
        return float(self.visa_ask(&#39;:offs?&#39;))

    @offset.setter
    def offset(self, val: float):
        &#34;&#34;&#34;
        Honestly don&#39;t know what this does. Read the documentation for more info


        Set the delayed timebase offset. The default unit is s.
        -(LeftTime - DelayRange/2) to (RightTime - DelayRange/2)

        LeftTime = 6 x MainScale - MainOffset
        RightTime = 6 x MainScale + MainOffset
        DelayRange = 12 x DelayScale
        Wherein, MainScale is the current main timebase scale of the oscilloscope,
        MainOffset is the current main timebase offset of the oscilloscope, and DelayScale is
        the current delayed timebase scale of the oscilloscope.

        :param val:
        :return:
        &#34;&#34;&#34;
        assert val

        self.visa_write(f&#39;:offs {val}&#39;)


class Timebase(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:tim&#34;

    def __init__(self, visa_resource):
        super().__init__(visa_resource)
        self.delay = TimebaseDelay(visa_resource)

    @property
    def scale(self):
        &#34;&#34;&#34;
        Query the main timebase scale. The default unit is s/div.
        :return:
        &#34;&#34;&#34;
        return float(self.visa_ask(&#39;:scal?&#39;))

    @scale.setter
    def scale(self, val: float):
        &#34;&#34;&#34;
        Set the main timebase scale. The default unit is s/div.

        :param val:
        :return:
        &#34;&#34;&#34;
        assert 50e-9 &lt;= val &lt;= 50
        self.visa_write(f&#39;:scal {val:.4e}&#39;)

    @property
    def mode(self) -&gt; str:
        &#34;&#34;&#34;
        Query the mode of the horizontal timebase.

        :return:
        &#34;&#34;&#34;
        return self.visa_ask(&#39;:mode?&#39;)

    @mode.setter
    def mode(self, val: str):
        &#34;&#34;&#34;
        Set the mode of the horizontal timebase.

        :param val:
        :return:
        &#34;&#34;&#34;
        val = val.lower()
        assert val in {ETimebaseMode.Main, ETimebaseMode.XY, ETimebaseMode.Roll}
        self.visa_write(f&#39;:mode {val}&#39;)

    @property
    def offset(self):
        &#34;&#34;&#34;
        Query the main timebase offset. The default unit is s.
        :return:
        &#34;&#34;&#34;
        return self.visa_ask(&#39;:offs?&#39;)

    @offset.setter
    def offset(self, val):
        &#34;&#34;&#34;
        Set the main timebase offset. The default unit is s.
        :param val:
        :return:
        &#34;&#34;&#34;
        self.visa_write(f&#39;:offs {-val:.4e}&#39;)


# incomplete
class TriggerEdge(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:trig:edg&#34;

    @property
    def trigger_level_v(self):
        return self.visa_ask(&#39;:lev?&#39;)

    @trigger_level_v.setter
    def trigger_level_v(self, level):
        self.visa_write(f&#39;:lev {level:.3e}&#39;)


# incomplete
class Trigger(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:trig&#34;

    def __init__(self, visa_resource):
        super().__init__(visa_resource)
        self.edge = TriggerEdge(visa_resource)

    @property
    def trigger_holdoff_s(self):
        return self.visa_ask(&#39;:hold?&#39;)

    @trigger_holdoff_s.setter
    def trigger_holdoff_s(self, holdoff):
        self.visa_write(&#39;:hold %.3e&#39; % holdoff)
        return self.get_trigger_holdoff_s()


class PreambleContext:
    &#34;&#34;&#34;
    Proper storage class for waveform preamble data
    &#34;&#34;&#34;

    def __init__(self, preamble_str):
        pre = preamble_str.split(&#39;,&#39;)

        self.format: int = int(pre[0])
        self.type: int = int(pre[1])
        self.points: int = int(pre[2])
        self.count: int = int(pre[3])
        self.x_increment: float = float(pre[4])
        self.x_origin: float = float(pre[5])
        self.x_reference: float = float(pre[6])
        self.y_increment: float = float(pre[7])
        self.y_origin: float = float(pre[8])
        self.y_reference: float = float(pre[9])


class Waveform(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    Complete
    &#34;&#34;&#34;
    cmd_hierarchy_str = &#34;:wav&#34;

    @property
    def source(self) -&gt; str:
        return self.visa_ask(&#39;:sour?&#39;)

    @source.setter
    def source(self, val: str):
        assert val in {*sources_analog, *sources_digital, *sources_math}
        self.visa_write(f&#39;:sour {val}&#39;)

    @property
    def mode(self) -&gt; str:
        return self.visa_ask(&#39;:mode?&#39;)

    @mode.setter
    def mode(self, val: str):
        assert val in waveform_modes
        self.visa_write(f&#39;:mode {val}&#39;)

    @property
    def read_format(self) -&gt; str:
        return self.visa_ask(&#39;:form?&#39;)

    @read_format.setter
    def read_format(self, val: str):
        assert val in waveform_read_formats
        self.visa_write(f&#39;:form {val}&#39;)

    @property
    def x_increment(self) -&gt; float:
        &#34;&#34;&#34;
        Query the time difference between two neighboring points
        of the specified channel source in the X direction.

        In NORMal mode:
            XINCrement = TimeScale/100.

        In RAW mode:
            XINCrement = 1/SampleRate.

        In MAX mode:
            XINCrement = TimeScale/100 when the instrument is in running status;
            XINCrement = 1/SampleRate when the instrument is in stop status.

        :return:
        &#34;&#34;&#34;
        return float(self.visa_ask(&#39;:xinc?&#39;))

    @property
    def y_increment(self) -&gt; float:
        &#34;&#34;&#34;
        Query the waveform increment of the specified channel source in the Y direction.
        The unit is the same as the current amplitude unit.

        The return value is related to the current data reading mode:
            In NORMal mode:
                YINCrement = VerticalScale/25

            In RAW mode:
                YINCrement is related to the Verticalscale of the internal waveform
                and the Verticalscale currently selected.

            In MAX mode:
                Instrument is in running status:
                    YINCrement = VerticalScale/25

                Instrument is in stop status:
                    YINCrement is related to the Verticalscale of the internal waveform and the Verticalscale
                    currently selected.

        :return:
        &#34;&#34;&#34;
        return float(self.visa_ask(&#39;:yinc?&#39;))

    @property
    def x_origin(self) -&gt; float:
        &#34;&#34;&#34;
        Query the start time of the waveform data of the channel source currently selected in the
        X direction.

        The return value is related to the current data reading mode:
            In NORMal mode:
                The query returns the start time of the waveform data displayed on the screen.
            In RAW mode:
                The query returns the start time of the waveform data in the internal memory.
            In MAX mode:
                the query returns the start time of the waveform data displayed on the
                screen when the instrument is in running status; the query returns the start time of
                the waveform data in the internal memory when the instrument is in stop status.

        :return:
        &#34;&#34;&#34;
        return float(self.visa_ask(&#39;:xor?&#39;))

    @property
    def y_origin(self) -&gt; int:
        &#34;&#34;&#34;
        Query the vertical offset relative to the vertical reference position of the specified channel
        source in the Y direction.

        The return value is related to the current data reading mode:
            In NORMal mode:
                YORigin = VerticalOffset/YINCrement.

            In RAW mode:
                YORigin is related to the Verticalscale of the internal waveform and the Verticalscale selected.

            In MAX mode:
                Instrument in running status:
                    YORigin = VerticalOffset/YINCrement
                Instrument in stop status:
                    YORigin is related to the Verticalscale of the internal waveform and the Verticalscale selected

        :return:
        &#34;&#34;&#34;
        return int(self.visa_ask(&#39;:yor?&#39;))

    @property
    def x_reference(self) -&gt; int:
        &#34;&#34;&#34;
        Query the reference time of the specified channel source in the X direction.

        The query returns 0 (namely the first point on the screen or in the internal memory)

        :return:
        &#34;&#34;&#34;
        return int(self.visa_ask(&#39;:xref?&#39;))

    @property
    def y_reference(self) -&gt; int:
        &#34;&#34;&#34;
        Query the vertical reference position of the specified channel source in the Y direction

        YREFerence is always 127 (the screen bottom is 0 and the screen top is 255).

        :return:
        &#34;&#34;&#34;
        return int(self.visa_ask(&#39;:yref?&#39;))

    @property
    def read_start_point(self):
        &#34;&#34;&#34;
        Query the start point of waveform data reading.
        :return:
        &#34;&#34;&#34;
        return int(self.visa_ask(&#39;:star?&#39;))

    @read_start_point.setter
    def read_start_point(self, val: int):
        &#34;&#34;&#34;
        Set the start point of waveform data reading.
        :param val:
        :return:
        &#34;&#34;&#34;
        self.visa_write(f&#39;:star {val}&#39;)

    @property
    def read_end_point(self):
        &#34;&#34;&#34;
        Query the stop point of waveform data reading.
        :return:
        &#34;&#34;&#34;
        return int(self.visa_ask(&#39;:stop?&#39;))

    @read_end_point.setter
    def read_end_point(self, val: int):
        &#34;&#34;&#34;
        Set the stop point of waveform data reading.
        :param val:
        :return:
        &#34;&#34;&#34;
        self.visa_write(f&#39;:stop {val}&#39;)

    @property
    def data_premable(self) -&gt; PreambleContext:
        &#34;&#34;&#34;
        Get information about oscilloscope axes.
        &#34;&#34;&#34;
        raw_pre = self.visa_ask(&#39;:pre?&#39;)
        return PreambleContext(raw_pre)

    # todo: review get is data handled directly from the Rigol class.
    #  Make sure this makes sense because this violates the pattern taken by the rest of the menus</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Rigol1000z.commands.Acquire"><code class="flex name class">
<span>class <span class="ident">Acquire</span></span>
<span>(</span><span>visa_resource: pyvisa.resources.resource.Resource, channels: List[<a title="Rigol1000z.commands.Channel" href="#Rigol1000z.commands.Channel">Channel</a>], idn: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Complete</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Acquire(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    Complete
    &#34;&#34;&#34;
    cmd_hierarchy_str = &#34;:acq&#34;

    def __init__(self, visa_resource: _visa.Resource, channels: List[Channel], idn: str = None):
        super().__init__(visa_resource, idn)
        self._linked_channels = channels

    @property
    def averages(self):
        &#34;&#34;&#34;
        Query the number of averages under the average acquisition mode.
        2^n (n is an integer from 1 to 10)
        :return: an integer between 2 and 1024.
        &#34;&#34;&#34;
        return int(self.visa_ask(&#39;:aver?&#39;))

    @averages.setter
    def averages(self, val):
        &#34;&#34;&#34;
        Set the number of averages under the average acquisition mode.

        :param val:
        :return:
        &#34;&#34;&#34;
        assert val in [2 ** n for n in range(1, 11)]
        self.visa_write(f&#39;:aver {int(val)}&#39;)

    @property
    def memory_depth(self) -&gt; int:
        &#34;&#34;&#34;
        Query the memory depth of the oscilloscope (namely the number of waveform
        points that can be stored in a single trigger sample). The default unit is pts (points).

        Auto mode is indicated with a -1 returned

        :return:
        &#34;&#34;&#34;
        md = self.visa_ask(&#39;:mdep?&#39;)
        return int(md) if md != &#39;AUTO&#39; else -1

    # todo: requires access to channels
    @memory_depth.setter
    def memory_depth(self, val: int):
        &#34;&#34;&#34;
        #todo: figure out if this command requires a run command before memory depth can be written

        Auto mode is indicated with a -1

        :param val: The number of points to acquire
        :return:
        &#34;&#34;&#34;

        num_enabled_chans = sum(1 if c.enabled else 0 for c in self._linked_channels)

        val = int(val) if val != -1 else &#39;AUTO&#39;

        if num_enabled_chans == 1:
            assert val in (&#39;AUTO&#39;, 12000, 120000, 1200000, 12000000, 24000000)
        elif num_enabled_chans == 2:
            assert val in (&#39;AUTO&#39;, 6000, 60000, 600000, 6000000, 12000000)
        elif num_enabled_chans in (3, 4):
            assert val in (&#39;AUTO&#39;, 3000, 30000, 300000, 3000000, 6000000)

        # todo: set to run mode if required
        self.visa_write(f&#39;:mdep {val}&#39;)

    @property
    def mode(self):
        return self.visa_ask(&#39;:type?&#39;)

    @mode.setter
    def mode(self, val: str):
        assert val in {EAcquireMode.Normal, EAcquireMode.Averages, EAcquireMode.HighResolution, EAcquireMode.Peak}
        self.visa_write(f&#39;:type {val}&#39;)

    @property
    def sampling_rate(self):
        &#34;&#34;&#34;
        Sample rate is the sample frequency of the oscilloscope, namely the waveform points sampled per second.

        The following equation describes the relationship among memory depth, sample rate, and waveform length:
            Memory Depth = Sample Rate x Waveform Length

        Wherein:
            Memory Depth can be set using the :ACQuire:MDEPth command
            Waveform Length is the product of:
                The horizontal timebase (set by the :TIMebase[:MAIN]:SCALe command)
                The number of the horizontal scales (12 for DS1000Z).

        :return: A float with units Sa/s
        &#34;&#34;&#34;
        return float(self.visa_ask(&#39;:srat?&#39;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="Rigol1000z.commands.Acquire.averages"><code class="name">var <span class="ident">averages</span></code></dt>
<dd>
<div class="desc"><p>Query the number of averages under the average acquisition mode.
2^n (n is an integer from 1 to 10)
:return: an integer between 2 and 1024.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def averages(self):
    &#34;&#34;&#34;
    Query the number of averages under the average acquisition mode.
    2^n (n is an integer from 1 to 10)
    :return: an integer between 2 and 1024.
    &#34;&#34;&#34;
    return int(self.visa_ask(&#39;:aver?&#39;))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Acquire.memory_depth"><code class="name">var <span class="ident">memory_depth</span> : int</code></dt>
<dd>
<div class="desc"><p>Query the memory depth of the oscilloscope (namely the number of waveform
points that can be stored in a single trigger sample). The default unit is pts (points).</p>
<p>Auto mode is indicated with a -1 returned</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def memory_depth(self) -&gt; int:
    &#34;&#34;&#34;
    Query the memory depth of the oscilloscope (namely the number of waveform
    points that can be stored in a single trigger sample). The default unit is pts (points).

    Auto mode is indicated with a -1 returned

    :return:
    &#34;&#34;&#34;
    md = self.visa_ask(&#39;:mdep?&#39;)
    return int(md) if md != &#39;AUTO&#39; else -1</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Acquire.mode"><code class="name">var <span class="ident">mode</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mode(self):
    return self.visa_ask(&#39;:type?&#39;)</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Acquire.sampling_rate"><code class="name">var <span class="ident">sampling_rate</span></code></dt>
<dd>
<div class="desc"><p>Sample rate is the sample frequency of the oscilloscope, namely the waveform points sampled per second.</p>
<p>The following equation describes the relationship among memory depth, sample rate, and waveform length:
Memory Depth = Sample Rate x Waveform Length</p>
<h2 id="wherein">Wherein</h2>
<p>Memory Depth can be set using the :ACQuire:MDEPth command
Waveform Length is the product of:
The horizontal timebase (set by the :TIMebase[:MAIN]:SCALe command)
The number of the horizontal scales (12 for DS1000Z).</p>
<p>:return: A float with units Sa/s</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sampling_rate(self):
    &#34;&#34;&#34;
    Sample rate is the sample frequency of the oscilloscope, namely the waveform points sampled per second.

    The following equation describes the relationship among memory depth, sample rate, and waveform length:
        Memory Depth = Sample Rate x Waveform Length

    Wherein:
        Memory Depth can be set using the :ACQuire:MDEPth command
        Waveform Length is the product of:
            The horizontal timebase (set by the :TIMebase[:MAIN]:SCALe command)
            The number of the horizontal scales (12 for DS1000Z).

    :return: A float with units Sa/s
    &#34;&#34;&#34;
    return float(self.visa_ask(&#39;:srat?&#39;))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.Calibrate"><code class="flex name class">
<span>class <span class="ident">Calibrate</span></span>
<span>(</span><span>visa_resource, idn: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Complete</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Calibrate(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    Complete
    &#34;&#34;&#34;

    cmd_hierarchy_str = &#34;:cal&#34;

    def set_auto_calibration(self, state: bool = True):
        self.visa_write(f&#34;:{&#39;star&#39; if state else &#39;quit&#39;}&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Rigol1000z.commands.Calibrate.set_auto_calibration"><code class="name flex">
<span>def <span class="ident">set_auto_calibration</span></span>(<span>self, state: bool = True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_auto_calibration(self, state: bool = True):
    self.visa_write(f&#34;:{&#39;star&#39; if state else &#39;quit&#39;}&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.Channel"><code class="flex name class">
<span>class <span class="ident">Channel</span></span>
<span>(</span><span>visa_resource: pyvisa.resources.resource.Resource, channel: int, idn: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Complete</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Channel(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    Complete
    &#34;&#34;&#34;

    def __init__(self, visa_resource: _visa.Resource, channel: int, idn: str = None):
        super().__init__(visa_resource, idn)
        self._channel = channel

        self.cmd_hierarchy_str = f&#34;:chan{self._channel}&#34;

    @property
    def channel(self):
        return self._channel

    @property
    def name(self):
        return f&#34;CHAN{self.channel}&#34;

    @property
    def bw_limit_20mhz(self):
        resp = self.visa_ask(&#39;:bwl?&#39;)
        return resp == &#34;20M&#34;

    @bw_limit_20mhz.setter
    def bw_limit_20mhz(self, val: bool):
        self.visa_write(f&#39;:bwl {&#34;20M&#34; if val else &#34;OFF&#34;}&#39;)

    @property
    def coupling(self):
        return self.visa_ask(&#39;:coup?&#39;)

    @coupling.setter
    def coupling(self, val):
        val = val.upper()
        assert val in (&#39;AC&#39;, &#39;DC&#39;, &#39;GND&#39;)
        self.visa_write(f&#39;:coup {val}&#39;)

    @property
    def enabled(self):
        return bool(int(self.visa_ask(&#39;:disp?&#39;)))

    @enabled.setter
    def enabled(self, val: bool):
        self.visa_write(f&#39;:disp {int(val is True)}&#39;)

    @property
    def invert(self):
        return bool(int(self.visa_ask(&#39;:inv?&#39;)))

    @invert.setter
    def invert(self, val: bool):
        self.visa_write(f&#39;:inv {int(val is True)}&#39;)

    @property
    def offset_v(self) -&gt; float:
        return float(self.visa_ask(&#39;:off?&#39;))

    @offset_v.setter
    def offset_v(self, val: float):
        &#34;&#34;&#34;
        Related to the current vertical scale and probe ratio

        When the probe ratio is 1X:
            vertical scale≥500mV/div: -100V to +100V
            vertical scale&lt;500mV/div: -2V to +2V
        When the probe ratio is 10X:
            vertical scale≥5V/div: -1000V to +1000V
            vertical scale&lt;5V/div: -20V to +20V

        :param val: The offset voltage to set (volts)
        &#34;&#34;&#34;
        # todo: check probe ratio and vertical scale to ensure valid value

        assert -1000. &lt;= val &lt;= 1000.
        self.visa_write(f&#39;:off {val:.4e}&#39;)

    @property
    def range_v(self) -&gt; float:
        return float(self.visa_ask(&#39;:rang?&#39;))

    @range_v.setter
    def range_v(self, val: float):
        assert 8e-3 &lt;= val &lt;= 800.
        self.visa_write(f&#39;:rang {val:.4e}&#39;)

    @property
    def calibration_delay(self) -&gt; float:
        &#34;&#34;&#34;
        Query the delay calibration time of the specified channel to calibrate the zero offset
        of the corresponding channel. The default unit is s.

        :return:
        &#34;&#34;&#34;
        return float(self.visa_ask(&#39;:tcal?&#39;))

    @calibration_delay.setter
    def calibration_delay(self, val: float):
        &#34;&#34;&#34;
        Can only be set to the specific values in the specified step. If the parameter you
        sent is not one of the specific values, the parameter will be set to the nearest specific
        values automatically

        :param val:
        :return:
        &#34;&#34;&#34;
        # todo: add addition rules to detect and ensure that channel can&#39;t leave the specified delay range

        assert -100e-9 &lt;= val &lt;= 100e-9
        self.visa_write(f&#39;:tcal {val:.4e}&#39;)

    @property
    def scale_v(self) -&gt; float:
        return float(self.visa_ask(&#39;:scal?&#39;))

    @scale_v.setter
    def scale_v(self, val: float):
        probe_ratio = self.probe_ratio
        assert 1e-3 * probe_ratio &lt;= val &lt;= 10. * probe_ratio
        self.visa_write(f&#39;:scal {val:.4e}&#39;)

    @property
    def probe_ratio(self) -&gt; float:
        return float(self.visa_ask(&#39;:prob?&#39;))

    @probe_ratio.setter
    def probe_ratio(self, val: float):
        assert val in {0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000}
        self.visa_write(f&#39;:prob {val:.4e}&#39;)

    @property
    def units(self) -&gt; str:
        return self.visa_ask(&#39;:unit?&#39;)

    @units.setter
    def units(self, val: str):
        val = val.lower()
        assert val in (&#39;volt&#39;, &#39;watt&#39;, &#39;amp&#39;, &#39;unkn&#39;)
        self.visa_write(f&#39;:unit {val}&#39;)

    @property
    def vernier(self):
        return bool(int(self.visa_ask(&#39;:vern?&#39;)))

    @vernier.setter
    def vernier(self, val: bool):
        self.visa_write(f&#39;:vern {int(val is True)}&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="Rigol1000z.commands.Channel.bw_limit_20mhz"><code class="name">var <span class="ident">bw_limit_20mhz</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bw_limit_20mhz(self):
    resp = self.visa_ask(&#39;:bwl?&#39;)
    return resp == &#34;20M&#34;</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Channel.calibration_delay"><code class="name">var <span class="ident">calibration_delay</span> : float</code></dt>
<dd>
<div class="desc"><p>Query the delay calibration time of the specified channel to calibrate the zero offset
of the corresponding channel. The default unit is s.</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def calibration_delay(self) -&gt; float:
    &#34;&#34;&#34;
    Query the delay calibration time of the specified channel to calibrate the zero offset
    of the corresponding channel. The default unit is s.

    :return:
    &#34;&#34;&#34;
    return float(self.visa_ask(&#39;:tcal?&#39;))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Channel.channel"><code class="name">var <span class="ident">channel</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def channel(self):
    return self._channel</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Channel.coupling"><code class="name">var <span class="ident">coupling</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def coupling(self):
    return self.visa_ask(&#39;:coup?&#39;)</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Channel.enabled"><code class="name">var <span class="ident">enabled</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def enabled(self):
    return bool(int(self.visa_ask(&#39;:disp?&#39;)))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Channel.invert"><code class="name">var <span class="ident">invert</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def invert(self):
    return bool(int(self.visa_ask(&#39;:inv?&#39;)))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Channel.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    return f&#34;CHAN{self.channel}&#34;</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Channel.offset_v"><code class="name">var <span class="ident">offset_v</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def offset_v(self) -&gt; float:
    return float(self.visa_ask(&#39;:off?&#39;))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Channel.probe_ratio"><code class="name">var <span class="ident">probe_ratio</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def probe_ratio(self) -&gt; float:
    return float(self.visa_ask(&#39;:prob?&#39;))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Channel.range_v"><code class="name">var <span class="ident">range_v</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def range_v(self) -&gt; float:
    return float(self.visa_ask(&#39;:rang?&#39;))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Channel.scale_v"><code class="name">var <span class="ident">scale_v</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scale_v(self) -&gt; float:
    return float(self.visa_ask(&#39;:scal?&#39;))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Channel.units"><code class="name">var <span class="ident">units</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def units(self) -&gt; str:
    return self.visa_ask(&#39;:unit?&#39;)</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Channel.vernier"><code class="name">var <span class="ident">vernier</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def vernier(self):
    return bool(int(self.visa_ask(&#39;:vern?&#39;)))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.Cursor"><code class="flex name class">
<span>class <span class="ident">Cursor</span></span>
<span>(</span><span>visa_resource, idn: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds additional checks and features exclusive to the Rigol1000z series of scopes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cursor(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:curs&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.Decoder"><code class="flex name class">
<span>class <span class="ident">Decoder</span></span>
<span>(</span><span>visa_resource, idn: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds additional checks and features exclusive to the Rigol1000z series of scopes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Decoder(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:dec&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.Display"><code class="flex name class">
<span>class <span class="ident">Display</span></span>
<span>(</span><span>visa_resource, idn: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Complete</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Display(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    Complete
    &#34;&#34;&#34;
    cmd_hierarchy_str = &#34;:disp&#34;

    def clear(self):
        return self.visa_write(&#39;:cle&#39;)

    # def data
    # this is currently implemented in the primary Rigol1000z class

    @property
    def mode(self):
        return self.visa_ask(&#39;:type?&#39;)

    @mode.setter
    def mode(self, val: str):
        assert val in {EDisplayMode.Vectors, EDisplayMode.Dots}
        self.visa_write(f&#39;:type {val}&#39;)

    @property
    def persistence_time(self):
        return self.visa_ask(&#39;:grad:time?&#39;)

    @persistence_time.setter
    def persistence_time(self, val: Union[float, str]):
        &#34;&#34;&#34;
         MIN: set the persistence time to its minimum to view the waveform changing in high refresh rate.

         Specific Values: set the persistence time to one of the values listed above to observe
        glitch that changes relatively slowly or glitch with low occurrence probability.

         INFinite: in this mode, the oscilloscope displays the newly acquired waveform
        without clearing the waveform formerly acquired. It can be used to measure noise
        and jitter as well as capture incidental events.

        :param val:
        :return:
        &#34;&#34;&#34;
        assert val in {&#34;MIN&#34;, 0.1, 0.2, 0.5, 1, 5, 10, &#34;INF&#34;}
        self.visa_write(f&#39;:grad:time {val}&#39;)

    @property
    def brightness(self):
        &#34;&#34;&#34;
        Query the screen brightness

        :return: A float between 0 and 1
        &#34;&#34;&#34;
        return float(self.visa_ask(&#39;:WBR?&#39;) / 100.0)

    @brightness.setter
    def brightness(self, val: float):
        &#34;&#34;&#34;
        Set the screen brightness

        :param val: A float between 0 and 1
        :return:
        &#34;&#34;&#34;
        assert 0.0 &lt;= val &lt;= 1.0
        self.visa_write(f&#39;:WBR {int(val * 100)}&#39;)

    @property
    def grid(self):
        &#34;&#34;&#34;
        Set or query the grid type of screen display
        :return:
        &#34;&#34;&#34;
        return self.visa_ask(&#39;:GRID?&#39;)

    @grid.setter
    def grid(self, val: float):
        assert val in {EDisplayGrid.Full, EDisplayGrid.Half, EDisplayGrid.NoGrid}
        self.visa_write(f&#39;:GRID {val}&#39;)

    @property
    def grid_brightness(self):
        &#34;&#34;&#34;
        Query the grid brightness

        :return: A float between 0 and 1
        &#34;&#34;&#34;
        return float(self.visa_ask(&#39;:GBR?&#39;) / 100.0)

    @grid_brightness.setter
    def grid_brightness(self, val: float):
        &#34;&#34;&#34;
        Set the grid brightness

        :param val: A float between 0 and 1
        :return:
        &#34;&#34;&#34;
        assert 0.0 &lt;= val &lt;= 1.0
        self.visa_write(f&#39;:GBR {int(val * 100)}&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="Rigol1000z.commands.Display.brightness"><code class="name">var <span class="ident">brightness</span></code></dt>
<dd>
<div class="desc"><p>Query the screen brightness</p>
<p>:return: A float between 0 and 1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def brightness(self):
    &#34;&#34;&#34;
    Query the screen brightness

    :return: A float between 0 and 1
    &#34;&#34;&#34;
    return float(self.visa_ask(&#39;:WBR?&#39;) / 100.0)</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Display.grid"><code class="name">var <span class="ident">grid</span></code></dt>
<dd>
<div class="desc"><p>Set or query the grid type of screen display
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def grid(self):
    &#34;&#34;&#34;
    Set or query the grid type of screen display
    :return:
    &#34;&#34;&#34;
    return self.visa_ask(&#39;:GRID?&#39;)</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Display.grid_brightness"><code class="name">var <span class="ident">grid_brightness</span></code></dt>
<dd>
<div class="desc"><p>Query the grid brightness</p>
<p>:return: A float between 0 and 1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def grid_brightness(self):
    &#34;&#34;&#34;
    Query the grid brightness

    :return: A float between 0 and 1
    &#34;&#34;&#34;
    return float(self.visa_ask(&#39;:GBR?&#39;) / 100.0)</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Display.mode"><code class="name">var <span class="ident">mode</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mode(self):
    return self.visa_ask(&#39;:type?&#39;)</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Display.persistence_time"><code class="name">var <span class="ident">persistence_time</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def persistence_time(self):
    return self.visa_ask(&#39;:grad:time?&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Rigol1000z.commands.Display.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    return self.visa_write(&#39;:cle&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.EventTable"><code class="flex name class">
<span>class <span class="ident">EventTable</span></span>
<span>(</span><span>visa_resource: pyvisa.resources.resource.Resource, etable_num: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Complete</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EventTable(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    Complete
    &#34;&#34;&#34;

    def __init__(self, visa_resource: _visa.Resource, etable_num: int):
        super().__init__(visa_resource)
        assert 1 &lt;= etable_num &lt;= 2
        self._etable_num = etable_num

        self.cmd_hierarchy_str = f&#34;:etab{self._etable_num}&#34;

    @property
    def enabled(self) -&gt; bool:
        &#34;&#34;&#34;
        Query the status of the decoding event table.
        :return: Boolean state of the event table
        &#34;&#34;&#34;
        # todo: query decoder&lt;n&gt;:display to ensure command is valid
        return bool(int(self.visa_ask(&#39;:disp?&#39;)))

    @enabled.setter
    def enabled(self, val: bool):
        &#34;&#34;&#34;
        Turn on or off the decoding event table.
        :param val: Boolean state to set the event table to
        :return:
        &#34;&#34;&#34;

        self.visa_write(f&#39;:disp {1 if val else 0}&#39;)

    @property
    def display_format(self) -&gt; bool:
        return bool(int(self.visa_ask(&#39;:form?&#39;)))

    @display_format.setter
    def display_format(self, val: str):
        assert val in {EEventtableFormat.Hex, EEventtableFormat.Ascii, EEventtableFormat.Decimal}
        self.visa_write(f&#39;:form {val}&#39;)

    @property
    def view(self) -&gt; str:
        return self.visa_ask(&#39;:view?&#39;)

    @view.setter
    def view(self, val: str):
        assert val in {EEventtableViewFormat.Package, EEventtableViewFormat.Detail, EEventtableViewFormat.Payload}
        self.visa_write(f&#39;:view {val}&#39;)

    @property
    def column(self) -&gt; int:
        &#34;&#34;&#34;
        Query the current column of the event table.
        :return:
        &#34;&#34;&#34;
        return int(self.visa_ask(&#39;:col?&#39;))

    @column.setter
    def column(self, val: int):
        &#34;&#34;&#34;
        Set the current column of the event table.

         When different decoder is selected (:DECoder&lt;n&gt;:MODE), the range of &lt;col&gt;
        differs.

        Parallel decoding: DATA
        RS232 decoding: TX|RX
        I2C decoding: DATA
        SPI decoding: MISO|MOSI

         If the TX or RX channel source in RS232 decoding or the MISO or MOSI channel
        source in SPI decoding is set to OFF, &lt;col&gt; cannot be set to the corresponding
        parameter.

        :param val:
        :return:
        &#34;&#34;&#34;

        self.visa_write(f&#39;:col {val}&#39;)

    @property
    def row(self) -&gt; int:
        &#34;&#34;&#34;
        The query returns the current row in integer. If the current even table is empty, the
        query returns 0.

        :return:
        &#34;&#34;&#34;

        return self.visa_ask(&#39;:row?&#39;)

    @row.setter
    def row(self, val: int):
        &#34;&#34;&#34;
        val must be 1 to the maximum number of rows of the current event table
        :param val:
        :return:
        &#34;&#34;&#34;
        # todo: figure out how many rows are in the event table

        self.visa_write(f&#39;:row {val}&#39;)

    @property
    def reverse_sorted(self) -&gt; bool:
        &#34;&#34;&#34;
        Query the display type of the decoding results in the event table.
        :return:
        &#34;&#34;&#34;
        return &#34;DESC&#34; == self.visa_ask(&#39;:sort?&#39;)

    @reverse_sorted.setter
    def reverse_sorted(self, val: bool):
        &#34;&#34;&#34;
        Set the display type of the decoding results in the event table.
        :param val:
        :return:
        &#34;&#34;&#34;
        self.visa_write(f&#39;:sort {&#34;DESC&#34; if val else &#34;ASC&#34;}&#39;)

    def get_data(self) -&gt; any:
        # todo: test and expand this when I have test data to work with
        return self.visa_ask(&#39;:data?&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="Rigol1000z.commands.EventTable.column"><code class="name">var <span class="ident">column</span> : int</code></dt>
<dd>
<div class="desc"><p>Query the current column of the event table.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def column(self) -&gt; int:
    &#34;&#34;&#34;
    Query the current column of the event table.
    :return:
    &#34;&#34;&#34;
    return int(self.visa_ask(&#39;:col?&#39;))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.EventTable.display_format"><code class="name">var <span class="ident">display_format</span> : bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def display_format(self) -&gt; bool:
    return bool(int(self.visa_ask(&#39;:form?&#39;)))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.EventTable.enabled"><code class="name">var <span class="ident">enabled</span> : bool</code></dt>
<dd>
<div class="desc"><p>Query the status of the decoding event table.
:return: Boolean state of the event table</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def enabled(self) -&gt; bool:
    &#34;&#34;&#34;
    Query the status of the decoding event table.
    :return: Boolean state of the event table
    &#34;&#34;&#34;
    # todo: query decoder&lt;n&gt;:display to ensure command is valid
    return bool(int(self.visa_ask(&#39;:disp?&#39;)))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.EventTable.reverse_sorted"><code class="name">var <span class="ident">reverse_sorted</span> : bool</code></dt>
<dd>
<div class="desc"><p>Query the display type of the decoding results in the event table.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def reverse_sorted(self) -&gt; bool:
    &#34;&#34;&#34;
    Query the display type of the decoding results in the event table.
    :return:
    &#34;&#34;&#34;
    return &#34;DESC&#34; == self.visa_ask(&#39;:sort?&#39;)</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.EventTable.row"><code class="name">var <span class="ident">row</span> : int</code></dt>
<dd>
<div class="desc"><p>The query returns the current row in integer. If the current even table is empty, the
query returns 0.</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def row(self) -&gt; int:
    &#34;&#34;&#34;
    The query returns the current row in integer. If the current even table is empty, the
    query returns 0.

    :return:
    &#34;&#34;&#34;

    return self.visa_ask(&#39;:row?&#39;)</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.EventTable.view"><code class="name">var <span class="ident">view</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def view(self) -&gt; str:
    return self.visa_ask(&#39;:view?&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Rigol1000z.commands.EventTable.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self) ‑> <built-in function any></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data(self) -&gt; any:
    # todo: test and expand this when I have test data to work with
    return self.visa_ask(&#39;:data?&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.Function"><code class="flex name class">
<span>class <span class="ident">Function</span></span>
<span>(</span><span>visa_resource, idn: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds additional checks and features exclusive to the Rigol1000z series of scopes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Function(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:func&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.IEEE488"><code class="flex name class">
<span>class <span class="ident">IEEE488</span></span>
<span>(</span><span>visa_resource, idn: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Complete</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IEEE488(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    Complete
    &#34;&#34;&#34;
    cmd_hierarchy_str = &#34;*&#34;

    def clear_event_registers(self) -&gt; None:
        &#34;&#34;&#34;
        Clear all the event registers and clear the error queue.
        &#34;&#34;&#34;
        self.visa_ask(&#34;cls&#34;)

    @property
    def event_register_enable_mask(self) -&gt; int:
        &#34;&#34;&#34;
        Query the enable register for the standard event status register set.
        &#34;&#34;&#34;
        return int(self.visa_ask(&#34;ese?&#34;))

    @event_register_enable_mask.setter
    def event_register_enable_mask(self, val: int):
        &#34;&#34;&#34;
        Set the enable register for the standard event status register set.
        &#34;&#34;&#34;
        assert 0 &lt;= val &lt; 256
        self.visa_write(f&#34;ese {val}&#34;)

    def query_and_clear_event_register(self) -&gt; int:
        &#34;&#34;&#34;
        Query and clear the event register for the standard event status register.
        &#34;&#34;&#34;
        return int(self.visa_ask(&#34;esr?&#34;))

    @property
    def id_string(self) -&gt; str:
        return self.visa_ask(&#39;idn?&#39;)

    @property
    def operation_complete(self) -&gt; bool:
        return bool(int(self.visa_ask(&#39;opc?&#39;)))

    def reset(self) -&gt; None:
        &#34;&#34;&#34;
        Restore the instrument to the default state.
        &#34;&#34;&#34;
        print(&#34;Reset can take several seconds to complete&#34;)
        old_timeout = self.visa_resource.timeout
        self.visa_resource.timeout = None
        self.visa_write(&#34;rst&#34;)
        wait_for_resp = self.operation_complete  # Wait for queued response before moving onto next command
        self.visa_resource.timeout = old_timeout
        print(&#34;Reset complete&#34;)

    @property
    def status_register_enable_mask(self) -&gt; int:
        &#34;&#34;&#34;
        Query the enable register for the status byte register set.
        &#34;&#34;&#34;
        return int(self.visa_ask(&#34;sre?&#34;))

    @status_register_enable_mask.setter
    def status_register_enable_mask(self, val: int):
        &#34;&#34;&#34;
        Set the enable register for the status byte register set.
        &#34;&#34;&#34;
        assert 0 &lt;= val &lt; 256
        self.visa_write(f&#34;sre {val}&#34;)

    def query_and_clear_status_register(self) -&gt; int:
        &#34;&#34;&#34;
        Query the event register for the status byte register.
        The value of the status byte register is set to 0 after this command is executed.
        &#34;&#34;&#34;
        return int(self.visa_ask(&#34;stb?&#34;))

    def self_test(self) -&gt; int:
        &#34;&#34;&#34;
        Perform a self-test and then return the self-test results
        &#34;&#34;&#34;
        return int(self.visa_ask(&#34;tst?&#34;))

    def wait_until_command_completion(self) -&gt; int:
        &#34;&#34;&#34;
        Wait for the operation to finish.
        The subsequent command can only be carried out after the
        current command has been executed.
        &#34;&#34;&#34;
        return int(self.visa_ask(&#34;wai&#34;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="Rigol1000z.commands.IEEE488.event_register_enable_mask"><code class="name">var <span class="ident">event_register_enable_mask</span> : int</code></dt>
<dd>
<div class="desc"><p>Query the enable register for the standard event status register set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def event_register_enable_mask(self) -&gt; int:
    &#34;&#34;&#34;
    Query the enable register for the standard event status register set.
    &#34;&#34;&#34;
    return int(self.visa_ask(&#34;ese?&#34;))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.IEEE488.id_string"><code class="name">var <span class="ident">id_string</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def id_string(self) -&gt; str:
    return self.visa_ask(&#39;idn?&#39;)</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.IEEE488.operation_complete"><code class="name">var <span class="ident">operation_complete</span> : bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def operation_complete(self) -&gt; bool:
    return bool(int(self.visa_ask(&#39;opc?&#39;)))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.IEEE488.status_register_enable_mask"><code class="name">var <span class="ident">status_register_enable_mask</span> : int</code></dt>
<dd>
<div class="desc"><p>Query the enable register for the status byte register set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def status_register_enable_mask(self) -&gt; int:
    &#34;&#34;&#34;
    Query the enable register for the status byte register set.
    &#34;&#34;&#34;
    return int(self.visa_ask(&#34;sre?&#34;))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Rigol1000z.commands.IEEE488.clear_event_registers"><code class="name flex">
<span>def <span class="ident">clear_event_registers</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Clear all the event registers and clear the error queue.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_event_registers(self) -&gt; None:
    &#34;&#34;&#34;
    Clear all the event registers and clear the error queue.
    &#34;&#34;&#34;
    self.visa_ask(&#34;cls&#34;)</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.IEEE488.query_and_clear_event_register"><code class="name flex">
<span>def <span class="ident">query_and_clear_event_register</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Query and clear the event register for the standard event status register.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def query_and_clear_event_register(self) -&gt; int:
    &#34;&#34;&#34;
    Query and clear the event register for the standard event status register.
    &#34;&#34;&#34;
    return int(self.visa_ask(&#34;esr?&#34;))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.IEEE488.query_and_clear_status_register"><code class="name flex">
<span>def <span class="ident">query_and_clear_status_register</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Query the event register for the status byte register.
The value of the status byte register is set to 0 after this command is executed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def query_and_clear_status_register(self) -&gt; int:
    &#34;&#34;&#34;
    Query the event register for the status byte register.
    The value of the status byte register is set to 0 after this command is executed.
    &#34;&#34;&#34;
    return int(self.visa_ask(&#34;stb?&#34;))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.IEEE488.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Restore the instrument to the default state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self) -&gt; None:
    &#34;&#34;&#34;
    Restore the instrument to the default state.
    &#34;&#34;&#34;
    print(&#34;Reset can take several seconds to complete&#34;)
    old_timeout = self.visa_resource.timeout
    self.visa_resource.timeout = None
    self.visa_write(&#34;rst&#34;)
    wait_for_resp = self.operation_complete  # Wait for queued response before moving onto next command
    self.visa_resource.timeout = old_timeout
    print(&#34;Reset complete&#34;)</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.IEEE488.self_test"><code class="name flex">
<span>def <span class="ident">self_test</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Perform a self-test and then return the self-test results</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def self_test(self) -&gt; int:
    &#34;&#34;&#34;
    Perform a self-test and then return the self-test results
    &#34;&#34;&#34;
    return int(self.visa_ask(&#34;tst?&#34;))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.IEEE488.wait_until_command_completion"><code class="name flex">
<span>def <span class="ident">wait_until_command_completion</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Wait for the operation to finish.
The subsequent command can only be carried out after the
current command has been executed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_until_command_completion(self) -&gt; int:
    &#34;&#34;&#34;
    Wait for the operation to finish.
    The subsequent command can only be carried out after the
    current command has been executed.
    &#34;&#34;&#34;
    return int(self.visa_ask(&#34;wai&#34;))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.LA"><code class="flex name class">
<span>class <span class="ident">LA</span></span>
<span>(</span><span>visa_resource, idn: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>The :LA commands are used to perform the related operations on the digital channels. These commands
are only applicable to DS1000Z Plus with the MSO upgrade option.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LA(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    The :LA commands are used to perform the related operations on the digital channels. These commands
    are only applicable to DS1000Z Plus with the MSO upgrade option.
    &#34;&#34;&#34;
    # todo: write this command menu
    cmd_hierarchy_str = &#34;:la&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.LAN"><code class="flex name class">
<span>class <span class="ident">LAN</span></span>
<span>(</span><span>visa_resource, idn: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds additional checks and features exclusive to the Rigol1000z series of scopes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LAN(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:lan&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.Mask"><code class="flex name class">
<span>class <span class="ident">Mask</span></span>
<span>(</span><span>visa_resource, idn: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>The :MASK commands are used to set and query the pass/fail test parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Mask(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    The :MASK commands are used to set and query the pass/fail test parameters.
    &#34;&#34;&#34;
    cmd_hierarchy_str = &#34;:mask&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.Math"><code class="flex name class">
<span>class <span class="ident">Math</span></span>
<span>(</span><span>visa_resource, idn: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds additional checks and features exclusive to the Rigol1000z series of scopes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Math(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:math&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.Measure"><code class="flex name class">
<span>class <span class="ident">Measure</span></span>
<span>(</span><span>visa_resource: pyvisa.resources.resource.Resource, idn: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>DS1000Z supports the auto measurement of the following 37 waveform parameters and provides the
statistic function for the measurement results.</p>
<p>In additional, you can use the frequency counter to make more precise frequency measurement.</p>
<p>Measure commands are used to set and query the measurement parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Measure(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    DS1000Z supports the auto measurement of the following 37 waveform parameters and provides the
    statistic function for the measurement results.

    In additional, you can use the frequency counter to make more precise frequency measurement.

    Measure commands are used to set and query the measurement parameters.
    &#34;&#34;&#34;
    cmd_hierarchy_str = &#34;:meas&#34;

    def __init__(self, visa_resource: _visa.Resource, idn: str = None):
        super().__init__(visa_resource, idn)

        self.counter = MeasureCounter(visa_resource, idn)
        self.setup = MeasureSetup(visa_resource, idn)
        self.statistic = MeasurementStatistic(visa_resource, idn)
        self.item = MeasurementItem(visa_resource, idn)

    @property
    def source(self) -&gt; str:
        &#34;&#34;&#34;
        Query the source of the current measurement parameter.
        :return: string identifying current measurement source
        &#34;&#34;&#34;
        return self.visa_ask(f&#39;:sour?&#39;)

    @source.setter
    def source(self, val: str):
        &#34;&#34;&#34;
        Set the source of the current measurement parameter.

        :param val: The source to select
        :return: None
        &#34;&#34;&#34;

        # Plus models support digital channels
        if self.osc_model in {ScopeModel.DS1104Z_S_Plus, ScopeModel.DS1074Z_S_Plus,
                              ScopeModel.DS1104Z_Plus, ScopeModel.DS1074Z_Plus}:
            assert val in {*sources_analog, *sources_digital, *sources_math}
        else:
            assert val in {*sources_analog, *sources_math}

        self.visa_write(f&#39;:sour {val}&#39;)

    def clear(self, item_num: int):
        &#34;&#34;&#34;
        Clear one or all of the last five measurement items enabled
        Pass the item number to disable that item
        Pass -1 to disable all

        :param item_num: Item to clear
        :return:
        &#34;&#34;&#34;
        assert item_num in {-1, 1, 2, 3, 4, 5}
        if item_num == -1:
            self.visa_write(f&#39;:cle ALL&#39;)
        else:
            self.visa_write(f&#39;:cle ITEM{item_num}&#39;)

    def recover(self, item_num: int):
        &#34;&#34;&#34;
        Recover the measurement item which has been cleared
        Pass the item number to recover that item
        Pass -1 to recover all

        :param item_num: Item to recover
        :return:
        &#34;&#34;&#34;
        assert item_num in {-1, 1, 2, 3, 4, 5}
        if item_num == -1:
            self.visa_write(f&#39;:rec ALL&#39;)
        else:
            self.visa_write(f&#39;:rec ITEM{item_num}&#39;)

    @property
    def all_measurement(self) -&gt; bool:
        return bool(int(self.visa_ask(f&#39;:adis?&#39;)))

    @all_measurement.setter
    def all_measurement(self, val: bool):
        &#34;&#34;&#34;
        Enable or disable the all measurement function, or query the status of the all measurement function

         The all measurement function can measure the following 29 parameters of the source at the same time:
            Voltage Parameters:
                Vmax, Vmin, Vpp, Vtop, Vbase, Vamp,
                Vupper, Vmid, Vlower, Vavg, Vrms,
                Overshoot, Preshoot, Period Vrms, and Variance

            Time Parameters:
                Period, Frequency, Rise Time, Fall Time, +Width, -Width, +Duty, -Duty, tVmax, and tVmin

            Other Parameters:
                +Rate, -Rate, Area, and Period Area.

         The all measurement function can measure CH1, CH2, CH3, CH4, and the MATH
        channel at the same time. You can send the :MEASure:AMSource command to set
        the source of the all measurement function.

        :param val:
        :return:
        &#34;&#34;&#34;
        self.visa_write(f&#39;:adis {1 if val else 0}&#39;)

    @property
    def all_measurement_source(self) -&gt; List[str]:
        &#34;&#34;&#34;
        Query the source(s) of the all measurement function.
        :return:
        &#34;&#34;&#34;
        return str(self.visa_ask(f&#39;:ams?&#39;)).split(&#34;,&#34;)

    @all_measurement_source.setter
    def all_measurement_source(self, val: Iterable[str]):
        &#34;&#34;&#34;
        Set the source(s) of the all measurement function.
        :param val:
        :return:
        &#34;&#34;&#34;
        self.visa_write(f&#39;:ams {&#34;,&#34;.join(val)}&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="Rigol1000z.commands.Measure.all_measurement"><code class="name">var <span class="ident">all_measurement</span> : bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def all_measurement(self) -&gt; bool:
    return bool(int(self.visa_ask(f&#39;:adis?&#39;)))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Measure.all_measurement_source"><code class="name">var <span class="ident">all_measurement_source</span> : List[str]</code></dt>
<dd>
<div class="desc"><p>Query the source(s) of the all measurement function.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def all_measurement_source(self) -&gt; List[str]:
    &#34;&#34;&#34;
    Query the source(s) of the all measurement function.
    :return:
    &#34;&#34;&#34;
    return str(self.visa_ask(f&#39;:ams?&#39;)).split(&#34;,&#34;)</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Measure.source"><code class="name">var <span class="ident">source</span> : str</code></dt>
<dd>
<div class="desc"><p>Query the source of the current measurement parameter.
:return: string identifying current measurement source</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def source(self) -&gt; str:
    &#34;&#34;&#34;
    Query the source of the current measurement parameter.
    :return: string identifying current measurement source
    &#34;&#34;&#34;
    return self.visa_ask(f&#39;:sour?&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Rigol1000z.commands.Measure.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, item_num: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear one or all of the last five measurement items enabled
Pass the item number to disable that item
Pass -1 to disable all</p>
<p>:param item_num: Item to clear
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self, item_num: int):
    &#34;&#34;&#34;
    Clear one or all of the last five measurement items enabled
    Pass the item number to disable that item
    Pass -1 to disable all

    :param item_num: Item to clear
    :return:
    &#34;&#34;&#34;
    assert item_num in {-1, 1, 2, 3, 4, 5}
    if item_num == -1:
        self.visa_write(f&#39;:cle ALL&#39;)
    else:
        self.visa_write(f&#39;:cle ITEM{item_num}&#39;)</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Measure.recover"><code class="name flex">
<span>def <span class="ident">recover</span></span>(<span>self, item_num: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Recover the measurement item which has been cleared
Pass the item number to recover that item
Pass -1 to recover all</p>
<p>:param item_num: Item to recover
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recover(self, item_num: int):
    &#34;&#34;&#34;
    Recover the measurement item which has been cleared
    Pass the item number to recover that item
    Pass -1 to recover all

    :param item_num: Item to recover
    :return:
    &#34;&#34;&#34;
    assert item_num in {-1, 1, 2, 3, 4, 5}
    if item_num == -1:
        self.visa_write(f&#39;:rec ALL&#39;)
    else:
        self.visa_write(f&#39;:rec ITEM{item_num}&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.MeasureCounter"><code class="flex name class">
<span>class <span class="ident">MeasureCounter</span></span>
<span>(</span><span>visa_resource, idn: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Complete</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MeasureCounter(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    Complete
    &#34;&#34;&#34;
    cmd_hierarchy_str = &#34;:meas:coun&#34;

    @property
    def source(self) -&gt; str:
        &#34;&#34;&#34;
        Query the source of the frequency counter, or disable the frequency counter.
        :return: string identifying counter measurement source
        &#34;&#34;&#34;
        return self.visa_ask(f&#39;:sour?&#39;)

    @source.setter
    def source(self, val: str):
        &#34;&#34;&#34;
        Set the source of the frequency counter, or disable the frequency counter.

        :param val: The counter source to select
        :return: None
        &#34;&#34;&#34;

        # Plus models support digital channels
        if self.osc_model in {ScopeModel.DS1104Z_S_Plus, ScopeModel.DS1074Z_S_Plus,
                              ScopeModel.DS1104Z_Plus, ScopeModel.DS1074Z_Plus}:
            assert val in {*sources_analog, *sources_digital}
        else:
            assert val in sources_analog

        self.visa_write(f&#39;:sour {val}&#39;)

    @property
    def value(self) -&gt; float:
        &#34;&#34;&#34;
        Query the measurement result of the frequency counter. The default unit is Hz.
        :return:
        &#34;&#34;&#34;
        return float(self.visa_ask(f&#39;:val?&#39;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="Rigol1000z.commands.MeasureCounter.source"><code class="name">var <span class="ident">source</span> : str</code></dt>
<dd>
<div class="desc"><p>Query the source of the frequency counter, or disable the frequency counter.
:return: string identifying counter measurement source</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def source(self) -&gt; str:
    &#34;&#34;&#34;
    Query the source of the frequency counter, or disable the frequency counter.
    :return: string identifying counter measurement source
    &#34;&#34;&#34;
    return self.visa_ask(f&#39;:sour?&#39;)</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasureCounter.value"><code class="name">var <span class="ident">value</span> : float</code></dt>
<dd>
<div class="desc"><p>Query the measurement result of the frequency counter. The default unit is Hz.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value(self) -&gt; float:
    &#34;&#34;&#34;
    Query the measurement result of the frequency counter. The default unit is Hz.
    :return:
    &#34;&#34;&#34;
    return float(self.visa_ask(f&#39;:val?&#39;))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.MeasureSetup"><code class="flex name class">
<span>class <span class="ident">MeasureSetup</span></span>
<span>(</span><span>visa_resource, idn: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Complete</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MeasureSetup(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    Complete
    &#34;&#34;&#34;
    cmd_hierarchy_str = &#34;:meas:set&#34;

    @property
    def max(self) -&gt; float:
        &#34;&#34;&#34;
        Query the upper limit of the threshold (expressed in the ratio of amplitude) in
        time, delay, and phase measurements.

        :return:
        &#34;&#34;&#34;
        return float(round(self.visa_ask(f&#39;:max?&#39;))) / 100.0

    @max.setter
    def max(self, val: float):
        &#34;&#34;&#34;
        Set the upper limit of the threshold (expressed in the ratio of amplitude) in
        time, delay, and phase measurements.

        :return:
        &#34;&#34;&#34;
        assert 0.07 &lt;= val &lt;= 0.95
        self.visa_write(f&#39;:max {round(val * 100.0)}&#39;)

    @property
    def mid(self) -&gt; float:
        &#34;&#34;&#34;
        Query the middle point of the threshold (expressed in the percentage of amplitude)
        in time, delay, and phase measurements.

        :return:
        &#34;&#34;&#34;
        return float(round(self.visa_ask(f&#39;:mid?&#39;))) / 100.0

    @max.setter
    def mid(self, val: float):
        &#34;&#34;&#34;
        Set the middle point of the threshold (expressed in the percentage of amplitude)
        in time, delay, and phase measurements.

        :return:
        &#34;&#34;&#34;
        assert 0.06 &lt;= val &lt;= 0.94
        self.visa_write(f&#39;:mid {round(val * 100.0)}&#39;)

    @property
    def min(self) -&gt; float:
        &#34;&#34;&#34;
        Query the lower limit of the threshold (expressed in the percentage of amplitude) in
        time, delay, and phase measurements.

        :return:
        &#34;&#34;&#34;
        return float(round(self.visa_ask(f&#39;:mid?&#39;))) / 100.0

    @max.setter
    def min(self, val: float):
        &#34;&#34;&#34;
        Set the lower limit of the threshold (expressed in the percentage of amplitude) in
        time, delay, and phase measurements.

        :return:
        &#34;&#34;&#34;
        assert 0.05 &lt;= val &lt;= 0.93
        self.visa_write(f&#39;:mid {round(val * 100.0)}&#39;)

    @property
    def phase_source_a(self) -&gt; str:
        &#34;&#34;&#34;
        Query source A of Phase 1→2 (rising edge) and Phase 1→2 (falling edge) measurements.
        :return:
        &#34;&#34;&#34;
        return str(self.visa_ask(f&#39;:psa?&#39;))

    @phase_source_a.setter
    def phase_source_a(self, val: str):
        &#34;&#34;&#34;
        Set source A of Phase (rising edge) 1→2 and Phase (falling edge) 1→2 measurements.
        :param val: The source to set the phase source to
        :return:
        &#34;&#34;&#34;
        # Plus models support digital channels
        if self.osc_model in {ScopeModel.DS1104Z_S_Plus, ScopeModel.DS1074Z_S_Plus,
                              ScopeModel.DS1104Z_Plus, ScopeModel.DS1074Z_Plus}:
            assert val in {*sources_analog, *sources_digital}
        else:
            assert val in sources_analog

        self.visa_write(f&#39;:psa {val}&#39;)

    @property
    def phase_source_b(self) -&gt; str:
        &#34;&#34;&#34;
        Query source B of Phase 1→2 (rising edge) and Phase 1→2 (falling edge) measurements.
        :return:
        &#34;&#34;&#34;
        return str(self.visa_ask(f&#39;:psb?&#39;))

    @phase_source_b.setter
    def phase_source_b(self, val: str):
        &#34;&#34;&#34;
        Set source B of Phase (rising edge) 1→2 and Phase (falling edge) 1→2 measurements.
        :param val: The source to set the phase source to
        :return:
        &#34;&#34;&#34;
        # Plus models support digital channels
        if self.osc_model in {ScopeModel.DS1104Z_S_Plus, ScopeModel.DS1074Z_S_Plus,
                              ScopeModel.DS1104Z_Plus, ScopeModel.DS1074Z_Plus}:
            assert val in {*sources_analog, *sources_digital}
        else:
            assert val in sources_analog

        self.visa_write(f&#39;:psb {val}&#39;)

    @property
    def delay_source_a(self) -&gt; str:
        &#34;&#34;&#34;
        Query source A of Delay 1→2 (rising edge) and Delay 1→2 (falling edge) measurements.

        :return:
        &#34;&#34;&#34;
        return str(self.visa_ask(f&#39;:dsa?&#39;))

    @delay_source_a.setter
    def delay_source_a(self, val: str):
        &#34;&#34;&#34;
        Set source A of Delay 1→2 (rising edge) and Delay 1→2 (falling edge) measurements.

        :param val:
        :return:
        &#34;&#34;&#34;

        # Plus models support digital channels
        if self.osc_model in {ScopeModel.DS1104Z_S_Plus, ScopeModel.DS1074Z_S_Plus,
                              ScopeModel.DS1104Z_Plus, ScopeModel.DS1074Z_Plus}:
            assert val in {*sources_analog, *sources_digital}
        else:
            assert val in sources_analog

        self.visa_write(f&#39;:dsa {val}&#39;)

    @property
    def delay_source_b(self) -&gt; str:
        &#34;&#34;&#34;
        Query source B of Delay 1→2 (rising edge) and Delay 1→2 (falling edge) measurements.

        :return:
        &#34;&#34;&#34;
        return str(self.visa_ask(f&#39;:dsb?&#39;))

    @delay_source_b.setter
    def delay_source_b(self, val: str):
        &#34;&#34;&#34;
        Set source B of Delay 1→2 (rising edge) and Delay 1→2 (falling edge) measurements.

        :param val:
        :return:
        &#34;&#34;&#34;

        # Plus models support digital channels
        if self.osc_model in {ScopeModel.DS1104Z_S_Plus, ScopeModel.DS1074Z_S_Plus,
                              ScopeModel.DS1104Z_Plus, ScopeModel.DS1074Z_Plus}:
            assert val in {*sources_analog, *sources_digital}
        else:
            assert val in sources_analog

        self.visa_write(f&#39;:dsb {val}&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="Rigol1000z.commands.MeasureSetup.delay_source_a"><code class="name">var <span class="ident">delay_source_a</span> : str</code></dt>
<dd>
<div class="desc"><p>Query source A of Delay 1→2 (rising edge) and Delay 1→2 (falling edge) measurements.</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def delay_source_a(self) -&gt; str:
    &#34;&#34;&#34;
    Query source A of Delay 1→2 (rising edge) and Delay 1→2 (falling edge) measurements.

    :return:
    &#34;&#34;&#34;
    return str(self.visa_ask(f&#39;:dsa?&#39;))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasureSetup.delay_source_b"><code class="name">var <span class="ident">delay_source_b</span> : str</code></dt>
<dd>
<div class="desc"><p>Query source B of Delay 1→2 (rising edge) and Delay 1→2 (falling edge) measurements.</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def delay_source_b(self) -&gt; str:
    &#34;&#34;&#34;
    Query source B of Delay 1→2 (rising edge) and Delay 1→2 (falling edge) measurements.

    :return:
    &#34;&#34;&#34;
    return str(self.visa_ask(f&#39;:dsb?&#39;))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasureSetup.max"><code class="name">var <span class="ident">max</span> : float</code></dt>
<dd>
<div class="desc"><p>Query the upper limit of the threshold (expressed in the ratio of amplitude) in
time, delay, and phase measurements.</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max(self) -&gt; float:
    &#34;&#34;&#34;
    Query the upper limit of the threshold (expressed in the ratio of amplitude) in
    time, delay, and phase measurements.

    :return:
    &#34;&#34;&#34;
    return float(round(self.visa_ask(f&#39;:max?&#39;))) / 100.0</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasureSetup.mid"><code class="name">var <span class="ident">mid</span> : float</code></dt>
<dd>
<div class="desc"><p>Query the upper limit of the threshold (expressed in the ratio of amplitude) in
time, delay, and phase measurements.</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max(self) -&gt; float:
    &#34;&#34;&#34;
    Query the upper limit of the threshold (expressed in the ratio of amplitude) in
    time, delay, and phase measurements.

    :return:
    &#34;&#34;&#34;
    return float(round(self.visa_ask(f&#39;:max?&#39;))) / 100.0</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasureSetup.min"><code class="name">var <span class="ident">min</span> : float</code></dt>
<dd>
<div class="desc"><p>Query the upper limit of the threshold (expressed in the ratio of amplitude) in
time, delay, and phase measurements.</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max(self) -&gt; float:
    &#34;&#34;&#34;
    Query the upper limit of the threshold (expressed in the ratio of amplitude) in
    time, delay, and phase measurements.

    :return:
    &#34;&#34;&#34;
    return float(round(self.visa_ask(f&#39;:max?&#39;))) / 100.0</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasureSetup.phase_source_a"><code class="name">var <span class="ident">phase_source_a</span> : str</code></dt>
<dd>
<div class="desc"><p>Query source A of Phase 1→2 (rising edge) and Phase 1→2 (falling edge) measurements.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def phase_source_a(self) -&gt; str:
    &#34;&#34;&#34;
    Query source A of Phase 1→2 (rising edge) and Phase 1→2 (falling edge) measurements.
    :return:
    &#34;&#34;&#34;
    return str(self.visa_ask(f&#39;:psa?&#39;))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasureSetup.phase_source_b"><code class="name">var <span class="ident">phase_source_b</span> : str</code></dt>
<dd>
<div class="desc"><p>Query source B of Phase 1→2 (rising edge) and Phase 1→2 (falling edge) measurements.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def phase_source_b(self) -&gt; str:
    &#34;&#34;&#34;
    Query source B of Phase 1→2 (rising edge) and Phase 1→2 (falling edge) measurements.
    :return:
    &#34;&#34;&#34;
    return str(self.visa_ask(f&#39;:psb?&#39;))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem"><code class="flex name class">
<span>class <span class="ident">MeasurementItem</span></span>
<span>(</span><span>visa_resource, idn: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Measure any waveform parameter of the specified source,
or query the measurement result of any waveform parameter of the specified source.</p>
<p>This class was written to simply the logic of this function as there are many rules.
All sources must be given when a query is called (no default args)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MeasurementItem(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    Measure any waveform parameter of the specified source,
    or query the measurement result of any waveform parameter of the specified source.

    This class was written to simply the logic of this function as there are many rules.
    All sources must be given when a query is called (no default args)
    &#34;&#34;&#34;
    cmd_hierarchy_str = &#34;:meas:item&#34;

    def _item_write(self, item, source) -&gt; None:
        self.visa_write(f&#34; {item},{source}&#34;)

    def _item_query(self, item, source) -&gt; float:
        &#34;&#34;&#34;
        Ensures that the statistic type is valid then builds and calls the visa query

        :param item:
        :param source:
        :return:
        &#34;&#34;&#34;

        return float(self.visa_ask(f&#34;? {item},{source}&#34;))

    # region single source commands

    # Voltage Maximum
    def get_voltage_max(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltageMax,
            source
        )

    def set_voltage_max(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltageMax,
            source
        )

    # Voltage Minimum
    def get_voltage_min(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltageMin,
            source
        )

    def set_voltage_min(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltageMin,
            source
        )

    # Voltage peak to peak
    def get_voltage_peak_to_peak(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltagePeakToPeak,
            source
        )

    def set_voltage_peak_to_peak(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltagePeakToPeak,
            source
        )

    # Voltage Top
    def get_voltage_top(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltageTop,
            source
        )

    def set_voltage_top(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltageTop,
            source
        )

    # Voltage Base
    def get_voltage_base(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltageBase,
            source
        )

    def set_voltage_base(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltageBase,
            source
        )

    # Voltage Amplitude
    def get_voltage_amp(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltageAmplitude,
            source
        )

    def set_voltage_amp(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltageAmplitude,
            source
        )

    # Voltage Average
    def get_voltage_average(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltageAverage,
            source
        )

    def set_voltage_average(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltageAverage,
            source
        )

    # Voltage RMS
    def get_voltage_rms(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltageRMS,
            source
        )

    def set_voltage_rms(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltageRMS,
            source
        )

    # Voltage Overshoot
    def get_voltage_overshoot(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltageOvershoot,
            source
        )

    def set_voltage_overshoot(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltageOvershoot,
            source
        )

    # Area
    def get_area(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.Area,
            source
        )

    def set_area(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.Area,
            source
        )

    # Period Area
    def get_period_area(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.AreaPeriod,
            source
        )

    def set_period_area(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.AreaPeriod,
            source
        )

    # Preshoot
    def get_preshoot(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltagePreshoot,
            source
        )

    def set_preshoot(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltagePreshoot,
            source
        )

    # period
    def get_period(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.Period,
            source
        )

    def set_period(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.Period,
            source
        )

    # frequency
    def get_frequency(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.Frequency,
            source
        )

    def set_frequency(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.Frequency,
            source
        )

    # rise time
    def get_rise_time(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.RiseTime,
            source
        )

    def set_rise_time(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.RiseTime,
            source
        )

    # fall time
    def get_fall_time(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.FallTime,
            source
        )

    def set_fall_time(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.FallTime,
            source
        )

    # width positive
    def get_width_positive(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.WidthPositive,
            source
        )

    def set_width_positive(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.WidthPositive,
            source
        )

    # width negative
    def get_width_negative(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.WidthNegative,
            source
        )

    def set_width_negative(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.WidthNegative,
            source
        )

    # duty positive
    def get_duty_positive(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.DutyPositive,
            source
        )

    def set_duty_positive(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.DutyPositive,
            source
        )

    # duty negative
    def get_duty_negative(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.DutyNegative,
            source
        )

    def set_duty_negative(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.DutyNegative,
            source
        )

    # time_voltage_max
    def get_time_voltage_max(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.TVMax,
            source
        )

    def set_time_voltage_max(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.TVMin,
            source
        )

    # time_voltage_min
    def get_time_voltage_min(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.TVMin,
            source
        )

    def set_time_voltage_min(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.TVMin,
            source
        )

    # Slew rate max
    def get_slew_rate_positive(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.SlewRatePositive,
            source
        )

    def set_slew_rate_positive(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.SlewRatePositive,
            source
        )

    # Slew rate min
    def get_slew_rate_negative(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.SlewRateNegative,
            source
        )

    def set_slew_rate_negative(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.SlewRateNegative,
            source
        )

    # Upper Voltage
    def get_voltage_upper(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltageUpper,
            source
        )

    def set_voltage_upper(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltageUpper,
            source
        )

    # Middle Voltage
    def get_voltage_mid(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltageMid,
            source
        )

    def set_voltage_mid(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltageMid,
            source
        )

    # Lower Voltage
    def get_voltage_lower(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VoltageLower,
            source
        )

    def set_voltage_lower(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VoltageLower,
            source
        )

    # Variance
    def get_variance(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.Variance,
            source
        )

    def set_variance(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.Variance,
            source
        )

    # Variance
    def get_voltage_rms_period(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.VRmsPeriod,
            source
        )

    def set_voltage_rms_period(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.VRmsPeriod,
            source
        )

    # Pulses Positive
    def get_pules_positive(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.PulsesPositive,
            source
        )

    def set_pules_positive(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.PulsesPositive,
            source
        )

    # Pulses Negative
    def get_pules_negative(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.PulsesPositive,
            source
        )

    def set_pules_negative(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.PulsesPositive,
            source
        )

    # Edges Positive
    def get_edges_positive(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.EdgesPositive,
            source
        )

    def set_edges_positive(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.EdgesPositive,
            source
        )

    # Edges Negative
    def get_edges_negative(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.EdgesNegative,
            source
        )

    def set_edges_negative(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._item_write(
            EMeasureItem.EdgesNegative,
            source
        )

    # endregion

    # region double source commands
    # Rise Delay
    def get_rise_delay(self, source_1: str, source_2: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.DelayRise,
            f&#34;{source_1},{source_2}&#34;
        )

    def set_rise_delay(self, source_1: str, source_2: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_write(
            EMeasureItem.DelayRise,
            f&#34;{source_1},{source_2}&#34;
        )

    # Fall Delay
    def get_fall_delay(self, source_1: str, source_2: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.DelayFall,
            f&#34;{source_1},{source_2}&#34;
        )

    def set_fall_delay(self, source_1: str, source_2: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_write(
            EMeasureItem.DelayFall,
            f&#34;{source_1},{source_2}&#34;
        )

    # Rise Phase
    def get_rise_phase(self, source_1: str, source_2: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.PhaseRise,
            f&#34;{source_1},{source_2}&#34;
        )

    def set_rise_phase(self, source_1: str, source_2: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_write(
            EMeasureItem.PhaseRise,
            f&#34;{source_1},{source_2}&#34;
        )

    # Fall Phase
    def get_fall_phase(self, source_1: str, source_2: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_query(
            EMeasureItem.PhaseFall,
            f&#34;{source_1},{source_2}&#34;
        )

    def set_fall_phase(self, source_1: str, source_2: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._item_write(
            EMeasureItem.PhaseFall,
            f&#34;{source_1},{source_2}&#34;
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Rigol1000z.commands.MeasurementItem.get_area"><code class="name flex">
<span>def <span class="ident">get_area</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_area(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.Area,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_duty_negative"><code class="name flex">
<span>def <span class="ident">get_duty_negative</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_duty_negative(self, source: str):
    assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.DutyNegative,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_duty_positive"><code class="name flex">
<span>def <span class="ident">get_duty_positive</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_duty_positive(self, source: str):
    assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.DutyPositive,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_edges_negative"><code class="name flex">
<span>def <span class="ident">get_edges_negative</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_edges_negative(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.EdgesNegative,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_edges_positive"><code class="name flex">
<span>def <span class="ident">get_edges_positive</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_edges_positive(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.EdgesPositive,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_fall_delay"><code class="name flex">
<span>def <span class="ident">get_fall_delay</span></span>(<span>self, source_1: str, source_2: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fall_delay(self, source_1: str, source_2: str):
    assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.DelayFall,
        f&#34;{source_1},{source_2}&#34;
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_fall_phase"><code class="name flex">
<span>def <span class="ident">get_fall_phase</span></span>(<span>self, source_1: str, source_2: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fall_phase(self, source_1: str, source_2: str):
    assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.PhaseFall,
        f&#34;{source_1},{source_2}&#34;
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_fall_time"><code class="name flex">
<span>def <span class="ident">get_fall_time</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fall_time(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.FallTime,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_frequency"><code class="name flex">
<span>def <span class="ident">get_frequency</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frequency(self, source: str):
    assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.Frequency,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_period"><code class="name flex">
<span>def <span class="ident">get_period</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_period(self, source: str):
    assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.Period,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_period_area"><code class="name flex">
<span>def <span class="ident">get_period_area</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_period_area(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.AreaPeriod,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_preshoot"><code class="name flex">
<span>def <span class="ident">get_preshoot</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_preshoot(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.VoltagePreshoot,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_pules_negative"><code class="name flex">
<span>def <span class="ident">get_pules_negative</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pules_negative(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.PulsesPositive,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_pules_positive"><code class="name flex">
<span>def <span class="ident">get_pules_positive</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pules_positive(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.PulsesPositive,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_rise_delay"><code class="name flex">
<span>def <span class="ident">get_rise_delay</span></span>(<span>self, source_1: str, source_2: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rise_delay(self, source_1: str, source_2: str):
    assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.DelayRise,
        f&#34;{source_1},{source_2}&#34;
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_rise_phase"><code class="name flex">
<span>def <span class="ident">get_rise_phase</span></span>(<span>self, source_1: str, source_2: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rise_phase(self, source_1: str, source_2: str):
    assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.PhaseRise,
        f&#34;{source_1},{source_2}&#34;
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_rise_time"><code class="name flex">
<span>def <span class="ident">get_rise_time</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rise_time(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.RiseTime,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_slew_rate_negative"><code class="name flex">
<span>def <span class="ident">get_slew_rate_negative</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_slew_rate_negative(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.SlewRateNegative,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_slew_rate_positive"><code class="name flex">
<span>def <span class="ident">get_slew_rate_positive</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_slew_rate_positive(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.SlewRatePositive,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_time_voltage_max"><code class="name flex">
<span>def <span class="ident">get_time_voltage_max</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_time_voltage_max(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.TVMax,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_time_voltage_min"><code class="name flex">
<span>def <span class="ident">get_time_voltage_min</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_time_voltage_min(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.TVMin,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_variance"><code class="name flex">
<span>def <span class="ident">get_variance</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variance(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.Variance,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_voltage_amp"><code class="name flex">
<span>def <span class="ident">get_voltage_amp</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_amp(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.VoltageAmplitude,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_voltage_average"><code class="name flex">
<span>def <span class="ident">get_voltage_average</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_average(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.VoltageAverage,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_voltage_base"><code class="name flex">
<span>def <span class="ident">get_voltage_base</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_base(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.VoltageBase,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_voltage_lower"><code class="name flex">
<span>def <span class="ident">get_voltage_lower</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_lower(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.VoltageLower,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_voltage_max"><code class="name flex">
<span>def <span class="ident">get_voltage_max</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_max(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.VoltageMax,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_voltage_mid"><code class="name flex">
<span>def <span class="ident">get_voltage_mid</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_mid(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.VoltageMid,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_voltage_min"><code class="name flex">
<span>def <span class="ident">get_voltage_min</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_min(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.VoltageMin,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_voltage_overshoot"><code class="name flex">
<span>def <span class="ident">get_voltage_overshoot</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_overshoot(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.VoltageOvershoot,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_voltage_peak_to_peak"><code class="name flex">
<span>def <span class="ident">get_voltage_peak_to_peak</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_peak_to_peak(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.VoltagePeakToPeak,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_voltage_rms"><code class="name flex">
<span>def <span class="ident">get_voltage_rms</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_rms(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.VoltageRMS,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_voltage_rms_period"><code class="name flex">
<span>def <span class="ident">get_voltage_rms_period</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_rms_period(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.VRmsPeriod,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_voltage_top"><code class="name flex">
<span>def <span class="ident">get_voltage_top</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_top(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.VoltageTop,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_voltage_upper"><code class="name flex">
<span>def <span class="ident">get_voltage_upper</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_upper(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.VoltageUpper,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_width_negative"><code class="name flex">
<span>def <span class="ident">get_width_negative</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_width_negative(self, source: str):
    assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.WidthNegative,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.get_width_positive"><code class="name flex">
<span>def <span class="ident">get_width_positive</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_width_positive(self, source: str):
    assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._item_query(
        EMeasureItem.WidthPositive,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_area"><code class="name flex">
<span>def <span class="ident">set_area</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_area(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.Area,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_duty_negative"><code class="name flex">
<span>def <span class="ident">set_duty_negative</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_duty_negative(self, source: str):
    assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.DutyNegative,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_duty_positive"><code class="name flex">
<span>def <span class="ident">set_duty_positive</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_duty_positive(self, source: str):
    assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.DutyPositive,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_edges_negative"><code class="name flex">
<span>def <span class="ident">set_edges_negative</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_edges_negative(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.EdgesNegative,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_edges_positive"><code class="name flex">
<span>def <span class="ident">set_edges_positive</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_edges_positive(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.EdgesPositive,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_fall_delay"><code class="name flex">
<span>def <span class="ident">set_fall_delay</span></span>(<span>self, source_1: str, source_2: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_fall_delay(self, source_1: str, source_2: str):
    assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._item_write(
        EMeasureItem.DelayFall,
        f&#34;{source_1},{source_2}&#34;
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_fall_phase"><code class="name flex">
<span>def <span class="ident">set_fall_phase</span></span>(<span>self, source_1: str, source_2: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_fall_phase(self, source_1: str, source_2: str):
    assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._item_write(
        EMeasureItem.PhaseFall,
        f&#34;{source_1},{source_2}&#34;
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_fall_time"><code class="name flex">
<span>def <span class="ident">set_fall_time</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_fall_time(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.FallTime,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_frequency"><code class="name flex">
<span>def <span class="ident">set_frequency</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_frequency(self, source: str):
    assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.Frequency,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_period"><code class="name flex">
<span>def <span class="ident">set_period</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_period(self, source: str):
    assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.Period,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_period_area"><code class="name flex">
<span>def <span class="ident">set_period_area</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_period_area(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.AreaPeriod,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_preshoot"><code class="name flex">
<span>def <span class="ident">set_preshoot</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_preshoot(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.VoltagePreshoot,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_pules_negative"><code class="name flex">
<span>def <span class="ident">set_pules_negative</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pules_negative(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.PulsesPositive,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_pules_positive"><code class="name flex">
<span>def <span class="ident">set_pules_positive</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pules_positive(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.PulsesPositive,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_rise_delay"><code class="name flex">
<span>def <span class="ident">set_rise_delay</span></span>(<span>self, source_1: str, source_2: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_rise_delay(self, source_1: str, source_2: str):
    assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._item_write(
        EMeasureItem.DelayRise,
        f&#34;{source_1},{source_2}&#34;
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_rise_phase"><code class="name flex">
<span>def <span class="ident">set_rise_phase</span></span>(<span>self, source_1: str, source_2: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_rise_phase(self, source_1: str, source_2: str):
    assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._item_write(
        EMeasureItem.PhaseRise,
        f&#34;{source_1},{source_2}&#34;
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_rise_time"><code class="name flex">
<span>def <span class="ident">set_rise_time</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_rise_time(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.RiseTime,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_slew_rate_negative"><code class="name flex">
<span>def <span class="ident">set_slew_rate_negative</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_slew_rate_negative(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.SlewRateNegative,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_slew_rate_positive"><code class="name flex">
<span>def <span class="ident">set_slew_rate_positive</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_slew_rate_positive(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.SlewRatePositive,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_time_voltage_max"><code class="name flex">
<span>def <span class="ident">set_time_voltage_max</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_time_voltage_max(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.TVMin,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_time_voltage_min"><code class="name flex">
<span>def <span class="ident">set_time_voltage_min</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_time_voltage_min(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.TVMin,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_variance"><code class="name flex">
<span>def <span class="ident">set_variance</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_variance(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.Variance,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_voltage_amp"><code class="name flex">
<span>def <span class="ident">set_voltage_amp</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_amp(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.VoltageAmplitude,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_voltage_average"><code class="name flex">
<span>def <span class="ident">set_voltage_average</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_average(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.VoltageAverage,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_voltage_base"><code class="name flex">
<span>def <span class="ident">set_voltage_base</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_base(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.VoltageBase,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_voltage_lower"><code class="name flex">
<span>def <span class="ident">set_voltage_lower</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_lower(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.VoltageLower,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_voltage_max"><code class="name flex">
<span>def <span class="ident">set_voltage_max</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_max(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.VoltageMax,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_voltage_mid"><code class="name flex">
<span>def <span class="ident">set_voltage_mid</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_mid(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.VoltageMid,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_voltage_min"><code class="name flex">
<span>def <span class="ident">set_voltage_min</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_min(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.VoltageMin,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_voltage_overshoot"><code class="name flex">
<span>def <span class="ident">set_voltage_overshoot</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_overshoot(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.VoltageOvershoot,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_voltage_peak_to_peak"><code class="name flex">
<span>def <span class="ident">set_voltage_peak_to_peak</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_peak_to_peak(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.VoltagePeakToPeak,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_voltage_rms"><code class="name flex">
<span>def <span class="ident">set_voltage_rms</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_rms(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.VoltageRMS,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_voltage_rms_period"><code class="name flex">
<span>def <span class="ident">set_voltage_rms_period</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_rms_period(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.VRmsPeriod,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_voltage_top"><code class="name flex">
<span>def <span class="ident">set_voltage_top</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_top(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.VoltageTop,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_voltage_upper"><code class="name flex">
<span>def <span class="ident">set_voltage_upper</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_upper(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.VoltageUpper,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_width_negative"><code class="name flex">
<span>def <span class="ident">set_width_negative</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_width_negative(self, source: str):
    assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.WidthNegative,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementItem.set_width_positive"><code class="name flex">
<span>def <span class="ident">set_width_positive</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_width_positive(self, source: str):
    assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    self._item_write(
        EMeasureItem.WidthPositive,
        source
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatistic"><code class="flex name class">
<span>class <span class="ident">MeasurementStatistic</span></span>
<span>(</span><span>visa_resource: pyvisa.resources.resource.Resource, idn: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds additional checks and features exclusive to the Rigol1000z series of scopes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MeasurementStatistic(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:meas:stat&#34;

    def __init__(self, visa_resource: _visa.Resource, idn: str):
        super().__init__(visa_resource, idn)
        self.item = MeasurementStatisticItem(visa_resource, idn)

    @property
    def enabled(self) -&gt; bool:
        &#34;&#34;&#34;
        Query the status of the statistic function.
        :return:
        &#34;&#34;&#34;
        return bool(int(self.visa_ask(f&#39;:disp?&#39;)))

    @enabled.setter
    def enabled(self, val: bool):
        &#34;&#34;&#34;
        Enable or disable the statistic function.
        :param val:
        :return:
        &#34;&#34;&#34;
        self.visa_write(f&#39;:disp {1 if val else 0}&#39;)

    @property
    def mode(self) -&gt; str:
        &#34;&#34;&#34;
         DIFFerence:
            The statistic results contain the current value, average value, standard deviation, and counts.

         EXTRemum:
            The statistic results contain the current value, average value, minimum, and maximum.

        :return:
        &#34;&#34;&#34;
        return self.visa_ask(f&#39;:mode?&#39;)

    @mode.setter
    def mode(self, val: str):
        &#34;&#34;&#34;
         DIFFerence:
            The statistic results contain the current value, average value, standard deviation, and counts.

         EXTRemum:
            The statistic results contain the current value, average value, minimum, and maximum.

         Sending the :MEASure:STATistic:DISPlay command can enable the statistic function.
        When the statistic function is enabled, the oscilloscope makes statistic and displays
        the statistic results of at most 5 measurement items that are turned on last.
        :return:
        &#34;&#34;&#34;

        assert val in {EMeasureStatisticMode.Difference, EMeasureStatisticMode.Extremum}
        self.visa_write(f&#39;:mode {val}&#39;)

    def reset(self) -&gt; None:
        &#34;&#34;&#34;
        Clear the history data and make statistic again.
        :return:
        &#34;&#34;&#34;
        self.visa_write(&#39;:res&#39;)

    def item(self):
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="Rigol1000z.commands.MeasurementStatistic.enabled"><code class="name">var <span class="ident">enabled</span> : bool</code></dt>
<dd>
<div class="desc"><p>Query the status of the statistic function.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def enabled(self) -&gt; bool:
    &#34;&#34;&#34;
    Query the status of the statistic function.
    :return:
    &#34;&#34;&#34;
    return bool(int(self.visa_ask(f&#39;:disp?&#39;)))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatistic.mode"><code class="name">var <span class="ident">mode</span> : str</code></dt>
<dd>
<div class="desc"><p> DIFFerence:
The statistic results contain the current value, average value, standard deviation, and counts.</p>
<p> EXTRemum:
The statistic results contain the current value, average value, minimum, and maximum.</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mode(self) -&gt; str:
    &#34;&#34;&#34;
     DIFFerence:
        The statistic results contain the current value, average value, standard deviation, and counts.

     EXTRemum:
        The statistic results contain the current value, average value, minimum, and maximum.

    :return:
    &#34;&#34;&#34;
    return self.visa_ask(f&#39;:mode?&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Rigol1000z.commands.MeasurementStatistic.item"><code class="name flex">
<span>def <span class="ident">item</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def item(self):
    pass</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatistic.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Clear the history data and make statistic again.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self) -&gt; None:
    &#34;&#34;&#34;
    Clear the history data and make statistic again.
    :return:
    &#34;&#34;&#34;
    self.visa_write(&#39;:res&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem"><code class="flex name class">
<span>class <span class="ident">MeasurementStatisticItem</span></span>
<span>(</span><span>visa_resource, idn: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable the statistic function of any waveform parameter of the specified source,
or query the statistic result of any waveform parameter of the specified source.</p>
<p>This class was written to simply the logic of this function as there are many rules.
All sources must be given when a query is called (no default args)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MeasurementStatisticItem(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    Enable the statistic function of any waveform parameter of the specified source,
    or query the statistic result of any waveform parameter of the specified source.

    This class was written to simply the logic of this function as there are many rules.
    All sources must be given when a query is called (no default args)
    &#34;&#34;&#34;
    cmd_hierarchy_str = &#34;:meas:stat:item&#34;

    def _statistic_item_write(self, item, source) -&gt; None:
        self.visa_write(f&#34; {item},{source}&#34;)

    def _statistic_item_query(self, stat_measurement_type, item, source) -&gt; float:
        &#34;&#34;&#34;
        Ensures that the statistic type is valid then builds and calls the visa query

        :param stat_measurement_type:
        :param item:
        :param source:
        :return:
        &#34;&#34;&#34;
        assert stat_measurement_type in {
            EMeasurementStatisticItemType.Maximum, EMeasurementStatisticItemType.Minimum,
            EMeasurementStatisticItemType.Current,
            EMeasurementStatisticItemType.Average,
            EMeasurementStatisticItemType.Deviation
        }
        return float(self.visa_ask(f&#34;? {stat_measurement_type},{item},{source}&#34;))

    # region single source commands

    # Voltage Maximum
    def get_voltage_max(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltageMax,
            source
        )

    def set_voltage_max(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltageMax,
            source
        )

    # Voltage Minimum
    def get_voltage_min(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltageMin,
            source
        )

    def set_voltage_min(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltageMin,
            source
        )

    # Voltage peak to peak
    def get_voltage_peak_to_peak(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltagePeakToPeak,
            source
        )

    def set_voltage_peak_to_peak(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltagePeakToPeak,
            source
        )

    # Voltage Top
    def get_voltage_top(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltageTop,
            source
        )

    def set_voltage_top(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltageTop,
            source
        )

    # Voltage Base
    def get_voltage_base(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltageBase,
            source
        )

    def set_voltage_base(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltageBase,
            source
        )

    # Voltage Amplitude
    def get_voltage_amp(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltageAmplitude,
            source
        )

    def set_voltage_amp(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltageAmplitude,
            source
        )

    # Voltage Average
    def get_voltage_average(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltageAverage,
            source
        )

    def set_voltage_average(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltageAverage,
            source
        )

    # Voltage RMS
    def get_voltage_rms(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltageRMS,
            source
        )

    def set_voltage_rms(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltageRMS,
            source
        )

    # Voltage Overshoot
    def get_voltage_overshoot(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltageOvershoot,
            source
        )

    def set_voltage_overshoot(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltageOvershoot,
            source
        )

    # Area
    def get_area(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.Area,
            source
        )

    def set_area(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.Area,
            source
        )

    # Period Area
    def get_period_area(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.AreaPeriod,
            source
        )

    def set_period_area(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.AreaPeriod,
            source
        )

    # Preshoot
    def get_preshoot(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltagePreshoot,
            source
        )

    def set_preshoot(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltagePreshoot,
            source
        )

    # period
    def get_period(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.Period,
            source
        )

    def set_period(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.Period,
            source
        )

    # frequency
    def get_frequency(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.Frequency,
            source
        )

    def set_frequency(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.Frequency,
            source
        )

    # rise time
    def get_rise_time(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.RiseTime,
            source
        )

    def set_rise_time(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.RiseTime,
            source
        )

    # fall time
    def get_fall_time(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.FallTime,
            source
        )

    def set_fall_time(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.FallTime,
            source
        )

    # width positive
    def get_width_positive(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.WidthPositive,
            source
        )

    def set_width_positive(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.WidthPositive,
            source
        )

    # width negative
    def get_width_negative(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.WidthNegative,
            source
        )

    def set_width_negative(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.WidthNegative,
            source
        )

    # duty positive
    def get_duty_positive(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.DutyPositive,
            source
        )

    def set_duty_positive(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.DutyPositive,
            source
        )

    # duty negative
    def get_duty_negative(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.DutyNegative,
            source
        )

    def set_duty_negative(self, source: str):
        assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.DutyNegative,
            source
        )

    # time_voltage_max
    def get_time_voltage_max(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.TVMax,
            source
        )

    def set_time_voltage_max(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.TVMin,
            source
        )

    # time_voltage_min
    def get_time_voltage_min(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.TVMin,
            source
        )

    def set_time_voltage_min(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.TVMin,
            source
        )

    # Slew rate max
    def get_slew_rate_positive(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.SlewRatePositive,
            source
        )

    def set_slew_rate_positive(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.SlewRatePositive,
            source
        )

    # Slew rate min
    def get_slew_rate_negative(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.SlewRateNegative,
            source
        )

    def set_slew_rate_negative(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.SlewRateNegative,
            source
        )

    # Upper Voltage
    def get_voltage_upper(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltageUpper,
            source
        )

    def set_voltage_upper(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltageUpper,
            source
        )

    # Middle Voltage
    def get_voltage_mid(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltageMid,
            source
        )

    def set_voltage_mid(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltageMid,
            source
        )

    # Lower Voltage
    def get_voltage_lower(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VoltageLower,
            source
        )

    def set_voltage_lower(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VoltageLower,
            source
        )

    # Variance
    def get_variance(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.Variance,
            source
        )

    def set_variance(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.Variance,
            source
        )

    # Variance
    def get_voltage_rms_period(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.VRmsPeriod,
            source
        )

    def set_voltage_rms_period(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.VRmsPeriod,
            source
        )

    # Pulses Positive
    def get_pules_positive(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.PulsesPositive,
            source
        )

    def set_pules_positive(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.PulsesPositive,
            source
        )

    # Pulses Negative
    def get_pules_negative(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.PulsesPositive,
            source
        )

    def set_pules_negative(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.PulsesPositive,
            source
        )

    # Edges Positive
    def get_edges_positive(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.EdgesPositive,
            source
        )

    def set_edges_positive(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.EdgesPositive,
            source
        )

    # Edges Negative
    def get_edges_negative(self, source: str, stat_measurement_type: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.EdgesNegative,
            source
        )

    def set_edges_negative(self, source: str):
        assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
        self._statistic_item_write(
            EMeasureItem.EdgesNegative,
            source
        )

    # endregion

    # region double source commands
    # Rise Delay
    def get_rise_delay(self, source_1: str, source_2: str, stat_measurement_type: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.DelayRise,
            f&#34;{source_1},{source_2}&#34;
        )

    def set_rise_delay(self, source_1: str, source_2: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_write(
            EMeasureItem.DelayRise,
            f&#34;{source_1},{source_2}&#34;
        )

    # Fall Delay
    def get_fall_delay(self, source_1: str, source_2: str, stat_measurement_type: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.DelayFall,
            f&#34;{source_1},{source_2}&#34;
        )

    def set_fall_delay(self, source_1: str, source_2: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_write(
            EMeasureItem.DelayFall,
            f&#34;{source_1},{source_2}&#34;
        )

    # Rise Phase
    def get_rise_phase(self, source_1: str, source_2: str, stat_measurement_type: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.PhaseRise,
            f&#34;{source_1},{source_2}&#34;
        )

    def set_rise_phase(self, source_1: str, source_2: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_write(
            EMeasureItem.PhaseRise,
            f&#34;{source_1},{source_2}&#34;
        )

    # Fall Phase
    def get_fall_phase(self, source_1: str, source_2: str, stat_measurement_type: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_query(
            stat_measurement_type,
            EMeasureItem.PhaseFall,
            f&#34;{source_1},{source_2}&#34;
        )

    def set_fall_phase(self, source_1: str, source_2: str):
        assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
        assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

        self._statistic_item_write(
            EMeasureItem.PhaseFall,
            f&#34;{source_1},{source_2}&#34;
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_area"><code class="name flex">
<span>def <span class="ident">get_area</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_area(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.Area,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_duty_negative"><code class="name flex">
<span>def <span class="ident">get_duty_negative</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_duty_negative(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.DutyNegative,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_duty_positive"><code class="name flex">
<span>def <span class="ident">get_duty_positive</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_duty_positive(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.DutyPositive,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_edges_negative"><code class="name flex">
<span>def <span class="ident">get_edges_negative</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_edges_negative(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.EdgesNegative,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_edges_positive"><code class="name flex">
<span>def <span class="ident">get_edges_positive</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_edges_positive(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.EdgesPositive,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_fall_delay"><code class="name flex">
<span>def <span class="ident">get_fall_delay</span></span>(<span>self, source_1: str, source_2: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fall_delay(self, source_1: str, source_2: str, stat_measurement_type: str):
    assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.DelayFall,
        f&#34;{source_1},{source_2}&#34;
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_fall_phase"><code class="name flex">
<span>def <span class="ident">get_fall_phase</span></span>(<span>self, source_1: str, source_2: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fall_phase(self, source_1: str, source_2: str, stat_measurement_type: str):
    assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.PhaseFall,
        f&#34;{source_1},{source_2}&#34;
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_fall_time"><code class="name flex">
<span>def <span class="ident">get_fall_time</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fall_time(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.FallTime,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_frequency"><code class="name flex">
<span>def <span class="ident">get_frequency</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frequency(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.Frequency,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_period"><code class="name flex">
<span>def <span class="ident">get_period</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_period(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.Period,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_period_area"><code class="name flex">
<span>def <span class="ident">get_period_area</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_period_area(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.AreaPeriod,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_preshoot"><code class="name flex">
<span>def <span class="ident">get_preshoot</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_preshoot(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.VoltagePreshoot,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_pules_negative"><code class="name flex">
<span>def <span class="ident">get_pules_negative</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pules_negative(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.PulsesPositive,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_pules_positive"><code class="name flex">
<span>def <span class="ident">get_pules_positive</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pules_positive(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.PulsesPositive,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_rise_delay"><code class="name flex">
<span>def <span class="ident">get_rise_delay</span></span>(<span>self, source_1: str, source_2: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rise_delay(self, source_1: str, source_2: str, stat_measurement_type: str):
    assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.DelayRise,
        f&#34;{source_1},{source_2}&#34;
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_rise_phase"><code class="name flex">
<span>def <span class="ident">get_rise_phase</span></span>(<span>self, source_1: str, source_2: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rise_phase(self, source_1: str, source_2: str, stat_measurement_type: str):
    assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.PhaseRise,
        f&#34;{source_1},{source_2}&#34;
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_rise_time"><code class="name flex">
<span>def <span class="ident">get_rise_time</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rise_time(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.RiseTime,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_slew_rate_negative"><code class="name flex">
<span>def <span class="ident">get_slew_rate_negative</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_slew_rate_negative(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.SlewRateNegative,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_slew_rate_positive"><code class="name flex">
<span>def <span class="ident">get_slew_rate_positive</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_slew_rate_positive(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.SlewRatePositive,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_time_voltage_max"><code class="name flex">
<span>def <span class="ident">get_time_voltage_max</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_time_voltage_max(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.TVMax,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_time_voltage_min"><code class="name flex">
<span>def <span class="ident">get_time_voltage_min</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_time_voltage_min(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.TVMin,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_variance"><code class="name flex">
<span>def <span class="ident">get_variance</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_variance(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.Variance,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_amp"><code class="name flex">
<span>def <span class="ident">get_voltage_amp</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_amp(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.VoltageAmplitude,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_average"><code class="name flex">
<span>def <span class="ident">get_voltage_average</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_average(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.VoltageAverage,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_base"><code class="name flex">
<span>def <span class="ident">get_voltage_base</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_base(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.VoltageBase,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_lower"><code class="name flex">
<span>def <span class="ident">get_voltage_lower</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_lower(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.VoltageLower,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_max"><code class="name flex">
<span>def <span class="ident">get_voltage_max</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_max(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.VoltageMax,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_mid"><code class="name flex">
<span>def <span class="ident">get_voltage_mid</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_mid(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.VoltageMid,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_min"><code class="name flex">
<span>def <span class="ident">get_voltage_min</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_min(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.VoltageMin,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_overshoot"><code class="name flex">
<span>def <span class="ident">get_voltage_overshoot</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_overshoot(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.VoltageOvershoot,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_peak_to_peak"><code class="name flex">
<span>def <span class="ident">get_voltage_peak_to_peak</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_peak_to_peak(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.VoltagePeakToPeak,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_rms"><code class="name flex">
<span>def <span class="ident">get_voltage_rms</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_rms(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.VoltageRMS,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_rms_period"><code class="name flex">
<span>def <span class="ident">get_voltage_rms_period</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_rms_period(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.VRmsPeriod,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_top"><code class="name flex">
<span>def <span class="ident">get_voltage_top</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_top(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.VoltageTop,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_upper"><code class="name flex">
<span>def <span class="ident">get_voltage_upper</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_voltage_upper(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.VoltageUpper,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_width_negative"><code class="name flex">
<span>def <span class="ident">get_width_negative</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_width_negative(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.WidthNegative,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.get_width_positive"><code class="name flex">
<span>def <span class="ident">get_width_positive</span></span>(<span>self, source: str, stat_measurement_type: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_width_positive(self, source: str, stat_measurement_type: str):
    assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._statistic_item_query(
        stat_measurement_type,
        EMeasureItem.WidthPositive,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_area"><code class="name flex">
<span>def <span class="ident">set_area</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_area(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.Area,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_duty_negative"><code class="name flex">
<span>def <span class="ident">set_duty_negative</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_duty_negative(self, source: str):
    assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.DutyNegative,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_duty_positive"><code class="name flex">
<span>def <span class="ident">set_duty_positive</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_duty_positive(self, source: str):
    assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.DutyPositive,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_edges_negative"><code class="name flex">
<span>def <span class="ident">set_edges_negative</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_edges_negative(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.EdgesNegative,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_edges_positive"><code class="name flex">
<span>def <span class="ident">set_edges_positive</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_edges_positive(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.EdgesPositive,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_fall_delay"><code class="name flex">
<span>def <span class="ident">set_fall_delay</span></span>(<span>self, source_1: str, source_2: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_fall_delay(self, source_1: str, source_2: str):
    assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._statistic_item_write(
        EMeasureItem.DelayFall,
        f&#34;{source_1},{source_2}&#34;
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_fall_phase"><code class="name flex">
<span>def <span class="ident">set_fall_phase</span></span>(<span>self, source_1: str, source_2: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_fall_phase(self, source_1: str, source_2: str):
    assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._statistic_item_write(
        EMeasureItem.PhaseFall,
        f&#34;{source_1},{source_2}&#34;
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_fall_time"><code class="name flex">
<span>def <span class="ident">set_fall_time</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_fall_time(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.FallTime,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_frequency"><code class="name flex">
<span>def <span class="ident">set_frequency</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_frequency(self, source: str):
    assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.Frequency,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_period"><code class="name flex">
<span>def <span class="ident">set_period</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_period(self, source: str):
    assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.Period,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_period_area"><code class="name flex">
<span>def <span class="ident">set_period_area</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_period_area(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.AreaPeriod,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_preshoot"><code class="name flex">
<span>def <span class="ident">set_preshoot</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_preshoot(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.VoltagePreshoot,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_pules_negative"><code class="name flex">
<span>def <span class="ident">set_pules_negative</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pules_negative(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.PulsesPositive,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_pules_positive"><code class="name flex">
<span>def <span class="ident">set_pules_positive</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pules_positive(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.PulsesPositive,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_rise_delay"><code class="name flex">
<span>def <span class="ident">set_rise_delay</span></span>(<span>self, source_1: str, source_2: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_rise_delay(self, source_1: str, source_2: str):
    assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._statistic_item_write(
        EMeasureItem.DelayRise,
        f&#34;{source_1},{source_2}&#34;
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_rise_phase"><code class="name flex">
<span>def <span class="ident">set_rise_phase</span></span>(<span>self, source_1: str, source_2: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_rise_phase(self, source_1: str, source_2: str):
    assert self.source_valid(source_1, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    assert self.source_valid(source_2, digital_valid=self.has_digital, ch_valid=True, math_valid=True)

    self._statistic_item_write(
        EMeasureItem.PhaseRise,
        f&#34;{source_1},{source_2}&#34;
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_rise_time"><code class="name flex">
<span>def <span class="ident">set_rise_time</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_rise_time(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.RiseTime,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_slew_rate_negative"><code class="name flex">
<span>def <span class="ident">set_slew_rate_negative</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_slew_rate_negative(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.SlewRateNegative,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_slew_rate_positive"><code class="name flex">
<span>def <span class="ident">set_slew_rate_positive</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_slew_rate_positive(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.SlewRatePositive,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_time_voltage_max"><code class="name flex">
<span>def <span class="ident">set_time_voltage_max</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_time_voltage_max(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.TVMin,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_time_voltage_min"><code class="name flex">
<span>def <span class="ident">set_time_voltage_min</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_time_voltage_min(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.TVMin,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_variance"><code class="name flex">
<span>def <span class="ident">set_variance</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_variance(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.Variance,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_amp"><code class="name flex">
<span>def <span class="ident">set_voltage_amp</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_amp(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.VoltageAmplitude,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_average"><code class="name flex">
<span>def <span class="ident">set_voltage_average</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_average(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.VoltageAverage,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_base"><code class="name flex">
<span>def <span class="ident">set_voltage_base</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_base(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.VoltageBase,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_lower"><code class="name flex">
<span>def <span class="ident">set_voltage_lower</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_lower(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.VoltageLower,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_max"><code class="name flex">
<span>def <span class="ident">set_voltage_max</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_max(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.VoltageMax,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_mid"><code class="name flex">
<span>def <span class="ident">set_voltage_mid</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_mid(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.VoltageMid,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_min"><code class="name flex">
<span>def <span class="ident">set_voltage_min</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_min(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.VoltageMin,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_overshoot"><code class="name flex">
<span>def <span class="ident">set_voltage_overshoot</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_overshoot(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.VoltageOvershoot,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_peak_to_peak"><code class="name flex">
<span>def <span class="ident">set_voltage_peak_to_peak</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_peak_to_peak(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.VoltagePeakToPeak,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_rms"><code class="name flex">
<span>def <span class="ident">set_voltage_rms</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_rms(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.VoltageRMS,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_rms_period"><code class="name flex">
<span>def <span class="ident">set_voltage_rms_period</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_rms_period(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.VRmsPeriod,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_top"><code class="name flex">
<span>def <span class="ident">set_voltage_top</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_top(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.VoltageTop,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_upper"><code class="name flex">
<span>def <span class="ident">set_voltage_upper</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_voltage_upper(self, source: str):
    assert self.source_valid(source, digital_valid=False, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.VoltageUpper,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_width_negative"><code class="name flex">
<span>def <span class="ident">set_width_negative</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_width_negative(self, source: str):
    assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.WidthNegative,
        source
    )</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.MeasurementStatisticItem.set_width_positive"><code class="name flex">
<span>def <span class="ident">set_width_positive</span></span>(<span>self, source: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_width_positive(self, source: str):
    assert self.source_valid(source, digital_valid=self.has_digital, ch_valid=True, math_valid=True)
    self._statistic_item_write(
        EMeasureItem.WidthPositive,
        source
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.PreambleContext"><code class="flex name class">
<span>class <span class="ident">PreambleContext</span></span>
<span>(</span><span>preamble_str)</span>
</code></dt>
<dd>
<div class="desc"><p>Proper storage class for waveform preamble data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PreambleContext:
    &#34;&#34;&#34;
    Proper storage class for waveform preamble data
    &#34;&#34;&#34;

    def __init__(self, preamble_str):
        pre = preamble_str.split(&#39;,&#39;)

        self.format: int = int(pre[0])
        self.type: int = int(pre[1])
        self.points: int = int(pre[2])
        self.count: int = int(pre[3])
        self.x_increment: float = float(pre[4])
        self.x_origin: float = float(pre[5])
        self.x_reference: float = float(pre[6])
        self.y_increment: float = float(pre[7])
        self.y_origin: float = float(pre[8])
        self.y_reference: float = float(pre[9])</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Reference"><code class="flex name class">
<span>class <span class="ident">Reference</span></span>
<span>(</span><span>visa_resource, idn: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds additional checks and features exclusive to the Rigol1000z series of scopes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Reference(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:ref&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.Source"><code class="flex name class">
<span>class <span class="ident">Source</span></span>
<span>(</span><span>visa_resource, idn: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds additional checks and features exclusive to the Rigol1000z series of scopes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Source(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:sour&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.Storage"><code class="flex name class">
<span>class <span class="ident">Storage</span></span>
<span>(</span><span>visa_resource, idn: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds additional checks and features exclusive to the Rigol1000z series of scopes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Storage(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:stor&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.System"><code class="flex name class">
<span>class <span class="ident">System</span></span>
<span>(</span><span>visa_resource, idn: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds additional checks and features exclusive to the Rigol1000z series of scopes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class System(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:syst&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.Timebase"><code class="flex name class">
<span>class <span class="ident">Timebase</span></span>
<span>(</span><span>visa_resource)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds additional checks and features exclusive to the Rigol1000z series of scopes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Timebase(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:tim&#34;

    def __init__(self, visa_resource):
        super().__init__(visa_resource)
        self.delay = TimebaseDelay(visa_resource)

    @property
    def scale(self):
        &#34;&#34;&#34;
        Query the main timebase scale. The default unit is s/div.
        :return:
        &#34;&#34;&#34;
        return float(self.visa_ask(&#39;:scal?&#39;))

    @scale.setter
    def scale(self, val: float):
        &#34;&#34;&#34;
        Set the main timebase scale. The default unit is s/div.

        :param val:
        :return:
        &#34;&#34;&#34;
        assert 50e-9 &lt;= val &lt;= 50
        self.visa_write(f&#39;:scal {val:.4e}&#39;)

    @property
    def mode(self) -&gt; str:
        &#34;&#34;&#34;
        Query the mode of the horizontal timebase.

        :return:
        &#34;&#34;&#34;
        return self.visa_ask(&#39;:mode?&#39;)

    @mode.setter
    def mode(self, val: str):
        &#34;&#34;&#34;
        Set the mode of the horizontal timebase.

        :param val:
        :return:
        &#34;&#34;&#34;
        val = val.lower()
        assert val in {ETimebaseMode.Main, ETimebaseMode.XY, ETimebaseMode.Roll}
        self.visa_write(f&#39;:mode {val}&#39;)

    @property
    def offset(self):
        &#34;&#34;&#34;
        Query the main timebase offset. The default unit is s.
        :return:
        &#34;&#34;&#34;
        return self.visa_ask(&#39;:offs?&#39;)

    @offset.setter
    def offset(self, val):
        &#34;&#34;&#34;
        Set the main timebase offset. The default unit is s.
        :param val:
        :return:
        &#34;&#34;&#34;
        self.visa_write(f&#39;:offs {-val:.4e}&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="Rigol1000z.commands.Timebase.mode"><code class="name">var <span class="ident">mode</span> : str</code></dt>
<dd>
<div class="desc"><p>Query the mode of the horizontal timebase.</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mode(self) -&gt; str:
    &#34;&#34;&#34;
    Query the mode of the horizontal timebase.

    :return:
    &#34;&#34;&#34;
    return self.visa_ask(&#39;:mode?&#39;)</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Timebase.offset"><code class="name">var <span class="ident">offset</span></code></dt>
<dd>
<div class="desc"><p>Query the main timebase offset. The default unit is s.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def offset(self):
    &#34;&#34;&#34;
    Query the main timebase offset. The default unit is s.
    :return:
    &#34;&#34;&#34;
    return self.visa_ask(&#39;:offs?&#39;)</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Timebase.scale"><code class="name">var <span class="ident">scale</span></code></dt>
<dd>
<div class="desc"><p>Query the main timebase scale. The default unit is s/div.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scale(self):
    &#34;&#34;&#34;
    Query the main timebase scale. The default unit is s/div.
    :return:
    &#34;&#34;&#34;
    return float(self.visa_ask(&#39;:scal?&#39;))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.TimebaseDelay"><code class="flex name class">
<span>class <span class="ident">TimebaseDelay</span></span>
<span>(</span><span>visa_resource, idn: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds additional checks and features exclusive to the Rigol1000z series of scopes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimebaseDelay(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:tim:del&#34;

    @property
    def enabled(self) -&gt; bool:
        return bool(int(self.visa_ask(&#39;:enab?&#39;)))

    @enabled.setter
    def enabled(self, val: bool):
        self.visa_write(f&#39;:enab {val}&#39;)

    @property
    def offset(self) -&gt; float:
        &#34;&#34;&#34;
        Query the delayed timebase offset. The default unit is s.

        :return:
        &#34;&#34;&#34;
        return float(self.visa_ask(&#39;:offs?&#39;))

    @offset.setter
    def offset(self, val: float):
        &#34;&#34;&#34;
        Honestly don&#39;t know what this does. Read the documentation for more info


        Set the delayed timebase offset. The default unit is s.
        -(LeftTime - DelayRange/2) to (RightTime - DelayRange/2)

        LeftTime = 6 x MainScale - MainOffset
        RightTime = 6 x MainScale + MainOffset
        DelayRange = 12 x DelayScale
        Wherein, MainScale is the current main timebase scale of the oscilloscope,
        MainOffset is the current main timebase offset of the oscilloscope, and DelayScale is
        the current delayed timebase scale of the oscilloscope.

        :param val:
        :return:
        &#34;&#34;&#34;
        assert val

        self.visa_write(f&#39;:offs {val}&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="Rigol1000z.commands.TimebaseDelay.enabled"><code class="name">var <span class="ident">enabled</span> : bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def enabled(self) -&gt; bool:
    return bool(int(self.visa_ask(&#39;:enab?&#39;)))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.TimebaseDelay.offset"><code class="name">var <span class="ident">offset</span> : float</code></dt>
<dd>
<div class="desc"><p>Query the delayed timebase offset. The default unit is s.</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def offset(self) -&gt; float:
    &#34;&#34;&#34;
    Query the delayed timebase offset. The default unit is s.

    :return:
    &#34;&#34;&#34;
    return float(self.visa_ask(&#39;:offs?&#39;))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.Trace"><code class="flex name class">
<span>class <span class="ident">Trace</span></span>
<span>(</span><span>visa_resource, idn: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds additional checks and features exclusive to the Rigol1000z series of scopes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Trace(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:trac&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.Trigger"><code class="flex name class">
<span>class <span class="ident">Trigger</span></span>
<span>(</span><span>visa_resource)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds additional checks and features exclusive to the Rigol1000z series of scopes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Trigger(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:trig&#34;

    def __init__(self, visa_resource):
        super().__init__(visa_resource)
        self.edge = TriggerEdge(visa_resource)

    @property
    def trigger_holdoff_s(self):
        return self.visa_ask(&#39;:hold?&#39;)

    @trigger_holdoff_s.setter
    def trigger_holdoff_s(self, holdoff):
        self.visa_write(&#39;:hold %.3e&#39; % holdoff)
        return self.get_trigger_holdoff_s()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="Rigol1000z.commands.Trigger.trigger_holdoff_s"><code class="name">var <span class="ident">trigger_holdoff_s</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def trigger_holdoff_s(self):
    return self.visa_ask(&#39;:hold?&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.TriggerEdge"><code class="flex name class">
<span>class <span class="ident">TriggerEdge</span></span>
<span>(</span><span>visa_resource, idn: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds additional checks and features exclusive to the Rigol1000z series of scopes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TriggerEdge(Rigol1000zCommandMenu):
    cmd_hierarchy_str = &#34;:trig:edg&#34;

    @property
    def trigger_level_v(self):
        return self.visa_ask(&#39;:lev?&#39;)

    @trigger_level_v.setter
    def trigger_level_v(self, level):
        self.visa_write(f&#39;:lev {level:.3e}&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="Rigol1000z.commands.TriggerEdge.trigger_level_v"><code class="name">var <span class="ident">trigger_level_v</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def trigger_level_v(self):
    return self.visa_ask(&#39;:lev?&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Rigol1000z.commands.Waveform"><code class="flex name class">
<span>class <span class="ident">Waveform</span></span>
<span>(</span><span>visa_resource, idn: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Complete</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Waveform(Rigol1000zCommandMenu):
    &#34;&#34;&#34;
    Complete
    &#34;&#34;&#34;
    cmd_hierarchy_str = &#34;:wav&#34;

    @property
    def source(self) -&gt; str:
        return self.visa_ask(&#39;:sour?&#39;)

    @source.setter
    def source(self, val: str):
        assert val in {*sources_analog, *sources_digital, *sources_math}
        self.visa_write(f&#39;:sour {val}&#39;)

    @property
    def mode(self) -&gt; str:
        return self.visa_ask(&#39;:mode?&#39;)

    @mode.setter
    def mode(self, val: str):
        assert val in waveform_modes
        self.visa_write(f&#39;:mode {val}&#39;)

    @property
    def read_format(self) -&gt; str:
        return self.visa_ask(&#39;:form?&#39;)

    @read_format.setter
    def read_format(self, val: str):
        assert val in waveform_read_formats
        self.visa_write(f&#39;:form {val}&#39;)

    @property
    def x_increment(self) -&gt; float:
        &#34;&#34;&#34;
        Query the time difference between two neighboring points
        of the specified channel source in the X direction.

        In NORMal mode:
            XINCrement = TimeScale/100.

        In RAW mode:
            XINCrement = 1/SampleRate.

        In MAX mode:
            XINCrement = TimeScale/100 when the instrument is in running status;
            XINCrement = 1/SampleRate when the instrument is in stop status.

        :return:
        &#34;&#34;&#34;
        return float(self.visa_ask(&#39;:xinc?&#39;))

    @property
    def y_increment(self) -&gt; float:
        &#34;&#34;&#34;
        Query the waveform increment of the specified channel source in the Y direction.
        The unit is the same as the current amplitude unit.

        The return value is related to the current data reading mode:
            In NORMal mode:
                YINCrement = VerticalScale/25

            In RAW mode:
                YINCrement is related to the Verticalscale of the internal waveform
                and the Verticalscale currently selected.

            In MAX mode:
                Instrument is in running status:
                    YINCrement = VerticalScale/25

                Instrument is in stop status:
                    YINCrement is related to the Verticalscale of the internal waveform and the Verticalscale
                    currently selected.

        :return:
        &#34;&#34;&#34;
        return float(self.visa_ask(&#39;:yinc?&#39;))

    @property
    def x_origin(self) -&gt; float:
        &#34;&#34;&#34;
        Query the start time of the waveform data of the channel source currently selected in the
        X direction.

        The return value is related to the current data reading mode:
            In NORMal mode:
                The query returns the start time of the waveform data displayed on the screen.
            In RAW mode:
                The query returns the start time of the waveform data in the internal memory.
            In MAX mode:
                the query returns the start time of the waveform data displayed on the
                screen when the instrument is in running status; the query returns the start time of
                the waveform data in the internal memory when the instrument is in stop status.

        :return:
        &#34;&#34;&#34;
        return float(self.visa_ask(&#39;:xor?&#39;))

    @property
    def y_origin(self) -&gt; int:
        &#34;&#34;&#34;
        Query the vertical offset relative to the vertical reference position of the specified channel
        source in the Y direction.

        The return value is related to the current data reading mode:
            In NORMal mode:
                YORigin = VerticalOffset/YINCrement.

            In RAW mode:
                YORigin is related to the Verticalscale of the internal waveform and the Verticalscale selected.

            In MAX mode:
                Instrument in running status:
                    YORigin = VerticalOffset/YINCrement
                Instrument in stop status:
                    YORigin is related to the Verticalscale of the internal waveform and the Verticalscale selected

        :return:
        &#34;&#34;&#34;
        return int(self.visa_ask(&#39;:yor?&#39;))

    @property
    def x_reference(self) -&gt; int:
        &#34;&#34;&#34;
        Query the reference time of the specified channel source in the X direction.

        The query returns 0 (namely the first point on the screen or in the internal memory)

        :return:
        &#34;&#34;&#34;
        return int(self.visa_ask(&#39;:xref?&#39;))

    @property
    def y_reference(self) -&gt; int:
        &#34;&#34;&#34;
        Query the vertical reference position of the specified channel source in the Y direction

        YREFerence is always 127 (the screen bottom is 0 and the screen top is 255).

        :return:
        &#34;&#34;&#34;
        return int(self.visa_ask(&#39;:yref?&#39;))

    @property
    def read_start_point(self):
        &#34;&#34;&#34;
        Query the start point of waveform data reading.
        :return:
        &#34;&#34;&#34;
        return int(self.visa_ask(&#39;:star?&#39;))

    @read_start_point.setter
    def read_start_point(self, val: int):
        &#34;&#34;&#34;
        Set the start point of waveform data reading.
        :param val:
        :return:
        &#34;&#34;&#34;
        self.visa_write(f&#39;:star {val}&#39;)

    @property
    def read_end_point(self):
        &#34;&#34;&#34;
        Query the stop point of waveform data reading.
        :return:
        &#34;&#34;&#34;
        return int(self.visa_ask(&#39;:stop?&#39;))

    @read_end_point.setter
    def read_end_point(self, val: int):
        &#34;&#34;&#34;
        Set the stop point of waveform data reading.
        :param val:
        :return:
        &#34;&#34;&#34;
        self.visa_write(f&#39;:stop {val}&#39;)

    @property
    def data_premable(self) -&gt; PreambleContext:
        &#34;&#34;&#34;
        Get information about oscilloscope axes.
        &#34;&#34;&#34;
        raw_pre = self.visa_ask(&#39;:pre?&#39;)
        return PreambleContext(raw_pre)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></li>
<li><a title="Rigol1000z.rigol1000zcommandmenu.CommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu">CommandMenu</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="Rigol1000z.commands.Waveform.data_premable"><code class="name">var <span class="ident">data_premable</span> : <a title="Rigol1000z.commands.PreambleContext" href="#Rigol1000z.commands.PreambleContext">PreambleContext</a></code></dt>
<dd>
<div class="desc"><p>Get information about oscilloscope axes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_premable(self) -&gt; PreambleContext:
    &#34;&#34;&#34;
    Get information about oscilloscope axes.
    &#34;&#34;&#34;
    raw_pre = self.visa_ask(&#39;:pre?&#39;)
    return PreambleContext(raw_pre)</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Waveform.mode"><code class="name">var <span class="ident">mode</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mode(self) -&gt; str:
    return self.visa_ask(&#39;:mode?&#39;)</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Waveform.read_end_point"><code class="name">var <span class="ident">read_end_point</span></code></dt>
<dd>
<div class="desc"><p>Query the stop point of waveform data reading.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def read_end_point(self):
    &#34;&#34;&#34;
    Query the stop point of waveform data reading.
    :return:
    &#34;&#34;&#34;
    return int(self.visa_ask(&#39;:stop?&#39;))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Waveform.read_format"><code class="name">var <span class="ident">read_format</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def read_format(self) -&gt; str:
    return self.visa_ask(&#39;:form?&#39;)</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Waveform.read_start_point"><code class="name">var <span class="ident">read_start_point</span></code></dt>
<dd>
<div class="desc"><p>Query the start point of waveform data reading.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def read_start_point(self):
    &#34;&#34;&#34;
    Query the start point of waveform data reading.
    :return:
    &#34;&#34;&#34;
    return int(self.visa_ask(&#39;:star?&#39;))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Waveform.source"><code class="name">var <span class="ident">source</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def source(self) -&gt; str:
    return self.visa_ask(&#39;:sour?&#39;)</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Waveform.x_increment"><code class="name">var <span class="ident">x_increment</span> : float</code></dt>
<dd>
<div class="desc"><p>Query the time difference between two neighboring points
of the specified channel source in the X direction.</p>
<p>In NORMal mode:
XINCrement = TimeScale/100.</p>
<p>In RAW mode:
XINCrement = 1/SampleRate.</p>
<p>In MAX mode:
XINCrement = TimeScale/100 when the instrument is in running status;
XINCrement = 1/SampleRate when the instrument is in stop status.</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x_increment(self) -&gt; float:
    &#34;&#34;&#34;
    Query the time difference between two neighboring points
    of the specified channel source in the X direction.

    In NORMal mode:
        XINCrement = TimeScale/100.

    In RAW mode:
        XINCrement = 1/SampleRate.

    In MAX mode:
        XINCrement = TimeScale/100 when the instrument is in running status;
        XINCrement = 1/SampleRate when the instrument is in stop status.

    :return:
    &#34;&#34;&#34;
    return float(self.visa_ask(&#39;:xinc?&#39;))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Waveform.x_origin"><code class="name">var <span class="ident">x_origin</span> : float</code></dt>
<dd>
<div class="desc"><p>Query the start time of the waveform data of the channel source currently selected in the
X direction.</p>
<p>The return value is related to the current data reading mode:
In NORMal mode:
The query returns the start time of the waveform data displayed on the screen.
In RAW mode:
The query returns the start time of the waveform data in the internal memory.
In MAX mode:
the query returns the start time of the waveform data displayed on the
screen when the instrument is in running status; the query returns the start time of
the waveform data in the internal memory when the instrument is in stop status.</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x_origin(self) -&gt; float:
    &#34;&#34;&#34;
    Query the start time of the waveform data of the channel source currently selected in the
    X direction.

    The return value is related to the current data reading mode:
        In NORMal mode:
            The query returns the start time of the waveform data displayed on the screen.
        In RAW mode:
            The query returns the start time of the waveform data in the internal memory.
        In MAX mode:
            the query returns the start time of the waveform data displayed on the
            screen when the instrument is in running status; the query returns the start time of
            the waveform data in the internal memory when the instrument is in stop status.

    :return:
    &#34;&#34;&#34;
    return float(self.visa_ask(&#39;:xor?&#39;))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Waveform.x_reference"><code class="name">var <span class="ident">x_reference</span> : int</code></dt>
<dd>
<div class="desc"><p>Query the reference time of the specified channel source in the X direction.</p>
<p>The query returns 0 (namely the first point on the screen or in the internal memory)</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x_reference(self) -&gt; int:
    &#34;&#34;&#34;
    Query the reference time of the specified channel source in the X direction.

    The query returns 0 (namely the first point on the screen or in the internal memory)

    :return:
    &#34;&#34;&#34;
    return int(self.visa_ask(&#39;:xref?&#39;))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Waveform.y_increment"><code class="name">var <span class="ident">y_increment</span> : float</code></dt>
<dd>
<div class="desc"><p>Query the waveform increment of the specified channel source in the Y direction.
The unit is the same as the current amplitude unit.</p>
<p>The return value is related to the current data reading mode:
In NORMal mode:
YINCrement = VerticalScale/25</p>
<pre><code>In RAW mode:
    YINCrement is related to the Verticalscale of the internal waveform
    and the Verticalscale currently selected.

In MAX mode:
    Instrument is in running status:
        YINCrement = VerticalScale/25

    Instrument is in stop status:
        YINCrement is related to the Verticalscale of the internal waveform and the Verticalscale
        currently selected.
</code></pre>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def y_increment(self) -&gt; float:
    &#34;&#34;&#34;
    Query the waveform increment of the specified channel source in the Y direction.
    The unit is the same as the current amplitude unit.

    The return value is related to the current data reading mode:
        In NORMal mode:
            YINCrement = VerticalScale/25

        In RAW mode:
            YINCrement is related to the Verticalscale of the internal waveform
            and the Verticalscale currently selected.

        In MAX mode:
            Instrument is in running status:
                YINCrement = VerticalScale/25

            Instrument is in stop status:
                YINCrement is related to the Verticalscale of the internal waveform and the Verticalscale
                currently selected.

    :return:
    &#34;&#34;&#34;
    return float(self.visa_ask(&#39;:yinc?&#39;))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Waveform.y_origin"><code class="name">var <span class="ident">y_origin</span> : int</code></dt>
<dd>
<div class="desc"><p>Query the vertical offset relative to the vertical reference position of the specified channel
source in the Y direction.</p>
<p>The return value is related to the current data reading mode:
In NORMal mode:
YORigin = VerticalOffset/YINCrement.</p>
<pre><code>In RAW mode:
    YORigin is related to the Verticalscale of the internal waveform and the Verticalscale selected.

In MAX mode:
    Instrument in running status:
        YORigin = VerticalOffset/YINCrement
    Instrument in stop status:
        YORigin is related to the Verticalscale of the internal waveform and the Verticalscale selected
</code></pre>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def y_origin(self) -&gt; int:
    &#34;&#34;&#34;
    Query the vertical offset relative to the vertical reference position of the specified channel
    source in the Y direction.

    The return value is related to the current data reading mode:
        In NORMal mode:
            YORigin = VerticalOffset/YINCrement.

        In RAW mode:
            YORigin is related to the Verticalscale of the internal waveform and the Verticalscale selected.

        In MAX mode:
            Instrument in running status:
                YORigin = VerticalOffset/YINCrement
            Instrument in stop status:
                YORigin is related to the Verticalscale of the internal waveform and the Verticalscale selected

    :return:
    &#34;&#34;&#34;
    return int(self.visa_ask(&#39;:yor?&#39;))</code></pre>
</details>
</dd>
<dt id="Rigol1000z.commands.Waveform.y_reference"><code class="name">var <span class="ident">y_reference</span> : int</code></dt>
<dd>
<div class="desc"><p>Query the vertical reference position of the specified channel source in the Y direction</p>
<p>YREFerence is always 127 (the screen bottom is 0 and the screen top is 255).</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def y_reference(self) -&gt; int:
    &#34;&#34;&#34;
    Query the vertical reference position of the specified channel source in the Y direction

    YREFerence is always 127 (the screen bottom is 0 and the screen top is 255).

    :return:
    &#34;&#34;&#34;
    return int(self.visa_ask(&#39;:yref?&#39;))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu">Rigol1000zCommandMenu</a></b></code>:
<ul class="hlist">
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.cmd_hierarchy_str" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.CommandMenu.cmd_hierarchy_str">cmd_hierarchy_str</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.has_digital">has_digital</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.rated_frequency">rated_frequency</a></code></li>
<li><code><a title="Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid" href="rigol1000zcommandmenu.html#Rigol1000z.rigol1000zcommandmenu.Rigol1000zCommandMenu.source_valid">source_valid</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Rigol1000z" href="index.html">Rigol1000z</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Rigol1000z.commands.Acquire" href="#Rigol1000z.commands.Acquire">Acquire</a></code></h4>
<ul class="">
<li><code><a title="Rigol1000z.commands.Acquire.averages" href="#Rigol1000z.commands.Acquire.averages">averages</a></code></li>
<li><code><a title="Rigol1000z.commands.Acquire.memory_depth" href="#Rigol1000z.commands.Acquire.memory_depth">memory_depth</a></code></li>
<li><code><a title="Rigol1000z.commands.Acquire.mode" href="#Rigol1000z.commands.Acquire.mode">mode</a></code></li>
<li><code><a title="Rigol1000z.commands.Acquire.sampling_rate" href="#Rigol1000z.commands.Acquire.sampling_rate">sampling_rate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.Calibrate" href="#Rigol1000z.commands.Calibrate">Calibrate</a></code></h4>
<ul class="">
<li><code><a title="Rigol1000z.commands.Calibrate.set_auto_calibration" href="#Rigol1000z.commands.Calibrate.set_auto_calibration">set_auto_calibration</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.Channel" href="#Rigol1000z.commands.Channel">Channel</a></code></h4>
<ul class="two-column">
<li><code><a title="Rigol1000z.commands.Channel.bw_limit_20mhz" href="#Rigol1000z.commands.Channel.bw_limit_20mhz">bw_limit_20mhz</a></code></li>
<li><code><a title="Rigol1000z.commands.Channel.calibration_delay" href="#Rigol1000z.commands.Channel.calibration_delay">calibration_delay</a></code></li>
<li><code><a title="Rigol1000z.commands.Channel.channel" href="#Rigol1000z.commands.Channel.channel">channel</a></code></li>
<li><code><a title="Rigol1000z.commands.Channel.coupling" href="#Rigol1000z.commands.Channel.coupling">coupling</a></code></li>
<li><code><a title="Rigol1000z.commands.Channel.enabled" href="#Rigol1000z.commands.Channel.enabled">enabled</a></code></li>
<li><code><a title="Rigol1000z.commands.Channel.invert" href="#Rigol1000z.commands.Channel.invert">invert</a></code></li>
<li><code><a title="Rigol1000z.commands.Channel.name" href="#Rigol1000z.commands.Channel.name">name</a></code></li>
<li><code><a title="Rigol1000z.commands.Channel.offset_v" href="#Rigol1000z.commands.Channel.offset_v">offset_v</a></code></li>
<li><code><a title="Rigol1000z.commands.Channel.probe_ratio" href="#Rigol1000z.commands.Channel.probe_ratio">probe_ratio</a></code></li>
<li><code><a title="Rigol1000z.commands.Channel.range_v" href="#Rigol1000z.commands.Channel.range_v">range_v</a></code></li>
<li><code><a title="Rigol1000z.commands.Channel.scale_v" href="#Rigol1000z.commands.Channel.scale_v">scale_v</a></code></li>
<li><code><a title="Rigol1000z.commands.Channel.units" href="#Rigol1000z.commands.Channel.units">units</a></code></li>
<li><code><a title="Rigol1000z.commands.Channel.vernier" href="#Rigol1000z.commands.Channel.vernier">vernier</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.Cursor" href="#Rigol1000z.commands.Cursor">Cursor</a></code></h4>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.Decoder" href="#Rigol1000z.commands.Decoder">Decoder</a></code></h4>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.Display" href="#Rigol1000z.commands.Display">Display</a></code></h4>
<ul class="two-column">
<li><code><a title="Rigol1000z.commands.Display.brightness" href="#Rigol1000z.commands.Display.brightness">brightness</a></code></li>
<li><code><a title="Rigol1000z.commands.Display.clear" href="#Rigol1000z.commands.Display.clear">clear</a></code></li>
<li><code><a title="Rigol1000z.commands.Display.grid" href="#Rigol1000z.commands.Display.grid">grid</a></code></li>
<li><code><a title="Rigol1000z.commands.Display.grid_brightness" href="#Rigol1000z.commands.Display.grid_brightness">grid_brightness</a></code></li>
<li><code><a title="Rigol1000z.commands.Display.mode" href="#Rigol1000z.commands.Display.mode">mode</a></code></li>
<li><code><a title="Rigol1000z.commands.Display.persistence_time" href="#Rigol1000z.commands.Display.persistence_time">persistence_time</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.EventTable" href="#Rigol1000z.commands.EventTable">EventTable</a></code></h4>
<ul class="two-column">
<li><code><a title="Rigol1000z.commands.EventTable.column" href="#Rigol1000z.commands.EventTable.column">column</a></code></li>
<li><code><a title="Rigol1000z.commands.EventTable.display_format" href="#Rigol1000z.commands.EventTable.display_format">display_format</a></code></li>
<li><code><a title="Rigol1000z.commands.EventTable.enabled" href="#Rigol1000z.commands.EventTable.enabled">enabled</a></code></li>
<li><code><a title="Rigol1000z.commands.EventTable.get_data" href="#Rigol1000z.commands.EventTable.get_data">get_data</a></code></li>
<li><code><a title="Rigol1000z.commands.EventTable.reverse_sorted" href="#Rigol1000z.commands.EventTable.reverse_sorted">reverse_sorted</a></code></li>
<li><code><a title="Rigol1000z.commands.EventTable.row" href="#Rigol1000z.commands.EventTable.row">row</a></code></li>
<li><code><a title="Rigol1000z.commands.EventTable.view" href="#Rigol1000z.commands.EventTable.view">view</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.Function" href="#Rigol1000z.commands.Function">Function</a></code></h4>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.IEEE488" href="#Rigol1000z.commands.IEEE488">IEEE488</a></code></h4>
<ul class="">
<li><code><a title="Rigol1000z.commands.IEEE488.clear_event_registers" href="#Rigol1000z.commands.IEEE488.clear_event_registers">clear_event_registers</a></code></li>
<li><code><a title="Rigol1000z.commands.IEEE488.event_register_enable_mask" href="#Rigol1000z.commands.IEEE488.event_register_enable_mask">event_register_enable_mask</a></code></li>
<li><code><a title="Rigol1000z.commands.IEEE488.id_string" href="#Rigol1000z.commands.IEEE488.id_string">id_string</a></code></li>
<li><code><a title="Rigol1000z.commands.IEEE488.operation_complete" href="#Rigol1000z.commands.IEEE488.operation_complete">operation_complete</a></code></li>
<li><code><a title="Rigol1000z.commands.IEEE488.query_and_clear_event_register" href="#Rigol1000z.commands.IEEE488.query_and_clear_event_register">query_and_clear_event_register</a></code></li>
<li><code><a title="Rigol1000z.commands.IEEE488.query_and_clear_status_register" href="#Rigol1000z.commands.IEEE488.query_and_clear_status_register">query_and_clear_status_register</a></code></li>
<li><code><a title="Rigol1000z.commands.IEEE488.reset" href="#Rigol1000z.commands.IEEE488.reset">reset</a></code></li>
<li><code><a title="Rigol1000z.commands.IEEE488.self_test" href="#Rigol1000z.commands.IEEE488.self_test">self_test</a></code></li>
<li><code><a title="Rigol1000z.commands.IEEE488.status_register_enable_mask" href="#Rigol1000z.commands.IEEE488.status_register_enable_mask">status_register_enable_mask</a></code></li>
<li><code><a title="Rigol1000z.commands.IEEE488.wait_until_command_completion" href="#Rigol1000z.commands.IEEE488.wait_until_command_completion">wait_until_command_completion</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.LA" href="#Rigol1000z.commands.LA">LA</a></code></h4>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.LAN" href="#Rigol1000z.commands.LAN">LAN</a></code></h4>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.Mask" href="#Rigol1000z.commands.Mask">Mask</a></code></h4>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.Math" href="#Rigol1000z.commands.Math">Math</a></code></h4>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.Measure" href="#Rigol1000z.commands.Measure">Measure</a></code></h4>
<ul class="">
<li><code><a title="Rigol1000z.commands.Measure.all_measurement" href="#Rigol1000z.commands.Measure.all_measurement">all_measurement</a></code></li>
<li><code><a title="Rigol1000z.commands.Measure.all_measurement_source" href="#Rigol1000z.commands.Measure.all_measurement_source">all_measurement_source</a></code></li>
<li><code><a title="Rigol1000z.commands.Measure.clear" href="#Rigol1000z.commands.Measure.clear">clear</a></code></li>
<li><code><a title="Rigol1000z.commands.Measure.recover" href="#Rigol1000z.commands.Measure.recover">recover</a></code></li>
<li><code><a title="Rigol1000z.commands.Measure.source" href="#Rigol1000z.commands.Measure.source">source</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.MeasureCounter" href="#Rigol1000z.commands.MeasureCounter">MeasureCounter</a></code></h4>
<ul class="">
<li><code><a title="Rigol1000z.commands.MeasureCounter.source" href="#Rigol1000z.commands.MeasureCounter.source">source</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasureCounter.value" href="#Rigol1000z.commands.MeasureCounter.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.MeasureSetup" href="#Rigol1000z.commands.MeasureSetup">MeasureSetup</a></code></h4>
<ul class="two-column">
<li><code><a title="Rigol1000z.commands.MeasureSetup.delay_source_a" href="#Rigol1000z.commands.MeasureSetup.delay_source_a">delay_source_a</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasureSetup.delay_source_b" href="#Rigol1000z.commands.MeasureSetup.delay_source_b">delay_source_b</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasureSetup.max" href="#Rigol1000z.commands.MeasureSetup.max">max</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasureSetup.mid" href="#Rigol1000z.commands.MeasureSetup.mid">mid</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasureSetup.min" href="#Rigol1000z.commands.MeasureSetup.min">min</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasureSetup.phase_source_a" href="#Rigol1000z.commands.MeasureSetup.phase_source_a">phase_source_a</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasureSetup.phase_source_b" href="#Rigol1000z.commands.MeasureSetup.phase_source_b">phase_source_b</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.MeasurementItem" href="#Rigol1000z.commands.MeasurementItem">MeasurementItem</a></code></h4>
<ul class="">
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_area" href="#Rigol1000z.commands.MeasurementItem.get_area">get_area</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_duty_negative" href="#Rigol1000z.commands.MeasurementItem.get_duty_negative">get_duty_negative</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_duty_positive" href="#Rigol1000z.commands.MeasurementItem.get_duty_positive">get_duty_positive</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_edges_negative" href="#Rigol1000z.commands.MeasurementItem.get_edges_negative">get_edges_negative</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_edges_positive" href="#Rigol1000z.commands.MeasurementItem.get_edges_positive">get_edges_positive</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_fall_delay" href="#Rigol1000z.commands.MeasurementItem.get_fall_delay">get_fall_delay</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_fall_phase" href="#Rigol1000z.commands.MeasurementItem.get_fall_phase">get_fall_phase</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_fall_time" href="#Rigol1000z.commands.MeasurementItem.get_fall_time">get_fall_time</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_frequency" href="#Rigol1000z.commands.MeasurementItem.get_frequency">get_frequency</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_period" href="#Rigol1000z.commands.MeasurementItem.get_period">get_period</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_period_area" href="#Rigol1000z.commands.MeasurementItem.get_period_area">get_period_area</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_preshoot" href="#Rigol1000z.commands.MeasurementItem.get_preshoot">get_preshoot</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_pules_negative" href="#Rigol1000z.commands.MeasurementItem.get_pules_negative">get_pules_negative</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_pules_positive" href="#Rigol1000z.commands.MeasurementItem.get_pules_positive">get_pules_positive</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_rise_delay" href="#Rigol1000z.commands.MeasurementItem.get_rise_delay">get_rise_delay</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_rise_phase" href="#Rigol1000z.commands.MeasurementItem.get_rise_phase">get_rise_phase</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_rise_time" href="#Rigol1000z.commands.MeasurementItem.get_rise_time">get_rise_time</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_slew_rate_negative" href="#Rigol1000z.commands.MeasurementItem.get_slew_rate_negative">get_slew_rate_negative</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_slew_rate_positive" href="#Rigol1000z.commands.MeasurementItem.get_slew_rate_positive">get_slew_rate_positive</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_time_voltage_max" href="#Rigol1000z.commands.MeasurementItem.get_time_voltage_max">get_time_voltage_max</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_time_voltage_min" href="#Rigol1000z.commands.MeasurementItem.get_time_voltage_min">get_time_voltage_min</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_variance" href="#Rigol1000z.commands.MeasurementItem.get_variance">get_variance</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_voltage_amp" href="#Rigol1000z.commands.MeasurementItem.get_voltage_amp">get_voltage_amp</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_voltage_average" href="#Rigol1000z.commands.MeasurementItem.get_voltage_average">get_voltage_average</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_voltage_base" href="#Rigol1000z.commands.MeasurementItem.get_voltage_base">get_voltage_base</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_voltage_lower" href="#Rigol1000z.commands.MeasurementItem.get_voltage_lower">get_voltage_lower</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_voltage_max" href="#Rigol1000z.commands.MeasurementItem.get_voltage_max">get_voltage_max</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_voltage_mid" href="#Rigol1000z.commands.MeasurementItem.get_voltage_mid">get_voltage_mid</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_voltage_min" href="#Rigol1000z.commands.MeasurementItem.get_voltage_min">get_voltage_min</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_voltage_overshoot" href="#Rigol1000z.commands.MeasurementItem.get_voltage_overshoot">get_voltage_overshoot</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_voltage_peak_to_peak" href="#Rigol1000z.commands.MeasurementItem.get_voltage_peak_to_peak">get_voltage_peak_to_peak</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_voltage_rms" href="#Rigol1000z.commands.MeasurementItem.get_voltage_rms">get_voltage_rms</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_voltage_rms_period" href="#Rigol1000z.commands.MeasurementItem.get_voltage_rms_period">get_voltage_rms_period</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_voltage_top" href="#Rigol1000z.commands.MeasurementItem.get_voltage_top">get_voltage_top</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_voltage_upper" href="#Rigol1000z.commands.MeasurementItem.get_voltage_upper">get_voltage_upper</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_width_negative" href="#Rigol1000z.commands.MeasurementItem.get_width_negative">get_width_negative</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.get_width_positive" href="#Rigol1000z.commands.MeasurementItem.get_width_positive">get_width_positive</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_area" href="#Rigol1000z.commands.MeasurementItem.set_area">set_area</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_duty_negative" href="#Rigol1000z.commands.MeasurementItem.set_duty_negative">set_duty_negative</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_duty_positive" href="#Rigol1000z.commands.MeasurementItem.set_duty_positive">set_duty_positive</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_edges_negative" href="#Rigol1000z.commands.MeasurementItem.set_edges_negative">set_edges_negative</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_edges_positive" href="#Rigol1000z.commands.MeasurementItem.set_edges_positive">set_edges_positive</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_fall_delay" href="#Rigol1000z.commands.MeasurementItem.set_fall_delay">set_fall_delay</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_fall_phase" href="#Rigol1000z.commands.MeasurementItem.set_fall_phase">set_fall_phase</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_fall_time" href="#Rigol1000z.commands.MeasurementItem.set_fall_time">set_fall_time</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_frequency" href="#Rigol1000z.commands.MeasurementItem.set_frequency">set_frequency</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_period" href="#Rigol1000z.commands.MeasurementItem.set_period">set_period</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_period_area" href="#Rigol1000z.commands.MeasurementItem.set_period_area">set_period_area</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_preshoot" href="#Rigol1000z.commands.MeasurementItem.set_preshoot">set_preshoot</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_pules_negative" href="#Rigol1000z.commands.MeasurementItem.set_pules_negative">set_pules_negative</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_pules_positive" href="#Rigol1000z.commands.MeasurementItem.set_pules_positive">set_pules_positive</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_rise_delay" href="#Rigol1000z.commands.MeasurementItem.set_rise_delay">set_rise_delay</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_rise_phase" href="#Rigol1000z.commands.MeasurementItem.set_rise_phase">set_rise_phase</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_rise_time" href="#Rigol1000z.commands.MeasurementItem.set_rise_time">set_rise_time</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_slew_rate_negative" href="#Rigol1000z.commands.MeasurementItem.set_slew_rate_negative">set_slew_rate_negative</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_slew_rate_positive" href="#Rigol1000z.commands.MeasurementItem.set_slew_rate_positive">set_slew_rate_positive</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_time_voltage_max" href="#Rigol1000z.commands.MeasurementItem.set_time_voltage_max">set_time_voltage_max</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_time_voltage_min" href="#Rigol1000z.commands.MeasurementItem.set_time_voltage_min">set_time_voltage_min</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_variance" href="#Rigol1000z.commands.MeasurementItem.set_variance">set_variance</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_voltage_amp" href="#Rigol1000z.commands.MeasurementItem.set_voltage_amp">set_voltage_amp</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_voltage_average" href="#Rigol1000z.commands.MeasurementItem.set_voltage_average">set_voltage_average</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_voltage_base" href="#Rigol1000z.commands.MeasurementItem.set_voltage_base">set_voltage_base</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_voltage_lower" href="#Rigol1000z.commands.MeasurementItem.set_voltage_lower">set_voltage_lower</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_voltage_max" href="#Rigol1000z.commands.MeasurementItem.set_voltage_max">set_voltage_max</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_voltage_mid" href="#Rigol1000z.commands.MeasurementItem.set_voltage_mid">set_voltage_mid</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_voltage_min" href="#Rigol1000z.commands.MeasurementItem.set_voltage_min">set_voltage_min</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_voltage_overshoot" href="#Rigol1000z.commands.MeasurementItem.set_voltage_overshoot">set_voltage_overshoot</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_voltage_peak_to_peak" href="#Rigol1000z.commands.MeasurementItem.set_voltage_peak_to_peak">set_voltage_peak_to_peak</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_voltage_rms" href="#Rigol1000z.commands.MeasurementItem.set_voltage_rms">set_voltage_rms</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_voltage_rms_period" href="#Rigol1000z.commands.MeasurementItem.set_voltage_rms_period">set_voltage_rms_period</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_voltage_top" href="#Rigol1000z.commands.MeasurementItem.set_voltage_top">set_voltage_top</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_voltage_upper" href="#Rigol1000z.commands.MeasurementItem.set_voltage_upper">set_voltage_upper</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_width_negative" href="#Rigol1000z.commands.MeasurementItem.set_width_negative">set_width_negative</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementItem.set_width_positive" href="#Rigol1000z.commands.MeasurementItem.set_width_positive">set_width_positive</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.MeasurementStatistic" href="#Rigol1000z.commands.MeasurementStatistic">MeasurementStatistic</a></code></h4>
<ul class="">
<li><code><a title="Rigol1000z.commands.MeasurementStatistic.enabled" href="#Rigol1000z.commands.MeasurementStatistic.enabled">enabled</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatistic.item" href="#Rigol1000z.commands.MeasurementStatistic.item">item</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatistic.mode" href="#Rigol1000z.commands.MeasurementStatistic.mode">mode</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatistic.reset" href="#Rigol1000z.commands.MeasurementStatistic.reset">reset</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.MeasurementStatisticItem" href="#Rigol1000z.commands.MeasurementStatisticItem">MeasurementStatisticItem</a></code></h4>
<ul class="">
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_area" href="#Rigol1000z.commands.MeasurementStatisticItem.get_area">get_area</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_duty_negative" href="#Rigol1000z.commands.MeasurementStatisticItem.get_duty_negative">get_duty_negative</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_duty_positive" href="#Rigol1000z.commands.MeasurementStatisticItem.get_duty_positive">get_duty_positive</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_edges_negative" href="#Rigol1000z.commands.MeasurementStatisticItem.get_edges_negative">get_edges_negative</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_edges_positive" href="#Rigol1000z.commands.MeasurementStatisticItem.get_edges_positive">get_edges_positive</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_fall_delay" href="#Rigol1000z.commands.MeasurementStatisticItem.get_fall_delay">get_fall_delay</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_fall_phase" href="#Rigol1000z.commands.MeasurementStatisticItem.get_fall_phase">get_fall_phase</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_fall_time" href="#Rigol1000z.commands.MeasurementStatisticItem.get_fall_time">get_fall_time</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_frequency" href="#Rigol1000z.commands.MeasurementStatisticItem.get_frequency">get_frequency</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_period" href="#Rigol1000z.commands.MeasurementStatisticItem.get_period">get_period</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_period_area" href="#Rigol1000z.commands.MeasurementStatisticItem.get_period_area">get_period_area</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_preshoot" href="#Rigol1000z.commands.MeasurementStatisticItem.get_preshoot">get_preshoot</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_pules_negative" href="#Rigol1000z.commands.MeasurementStatisticItem.get_pules_negative">get_pules_negative</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_pules_positive" href="#Rigol1000z.commands.MeasurementStatisticItem.get_pules_positive">get_pules_positive</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_rise_delay" href="#Rigol1000z.commands.MeasurementStatisticItem.get_rise_delay">get_rise_delay</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_rise_phase" href="#Rigol1000z.commands.MeasurementStatisticItem.get_rise_phase">get_rise_phase</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_rise_time" href="#Rigol1000z.commands.MeasurementStatisticItem.get_rise_time">get_rise_time</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_slew_rate_negative" href="#Rigol1000z.commands.MeasurementStatisticItem.get_slew_rate_negative">get_slew_rate_negative</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_slew_rate_positive" href="#Rigol1000z.commands.MeasurementStatisticItem.get_slew_rate_positive">get_slew_rate_positive</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_time_voltage_max" href="#Rigol1000z.commands.MeasurementStatisticItem.get_time_voltage_max">get_time_voltage_max</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_time_voltage_min" href="#Rigol1000z.commands.MeasurementStatisticItem.get_time_voltage_min">get_time_voltage_min</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_variance" href="#Rigol1000z.commands.MeasurementStatisticItem.get_variance">get_variance</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_amp" href="#Rigol1000z.commands.MeasurementStatisticItem.get_voltage_amp">get_voltage_amp</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_average" href="#Rigol1000z.commands.MeasurementStatisticItem.get_voltage_average">get_voltage_average</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_base" href="#Rigol1000z.commands.MeasurementStatisticItem.get_voltage_base">get_voltage_base</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_lower" href="#Rigol1000z.commands.MeasurementStatisticItem.get_voltage_lower">get_voltage_lower</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_max" href="#Rigol1000z.commands.MeasurementStatisticItem.get_voltage_max">get_voltage_max</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_mid" href="#Rigol1000z.commands.MeasurementStatisticItem.get_voltage_mid">get_voltage_mid</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_min" href="#Rigol1000z.commands.MeasurementStatisticItem.get_voltage_min">get_voltage_min</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_overshoot" href="#Rigol1000z.commands.MeasurementStatisticItem.get_voltage_overshoot">get_voltage_overshoot</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_peak_to_peak" href="#Rigol1000z.commands.MeasurementStatisticItem.get_voltage_peak_to_peak">get_voltage_peak_to_peak</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_rms" href="#Rigol1000z.commands.MeasurementStatisticItem.get_voltage_rms">get_voltage_rms</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_rms_period" href="#Rigol1000z.commands.MeasurementStatisticItem.get_voltage_rms_period">get_voltage_rms_period</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_top" href="#Rigol1000z.commands.MeasurementStatisticItem.get_voltage_top">get_voltage_top</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_voltage_upper" href="#Rigol1000z.commands.MeasurementStatisticItem.get_voltage_upper">get_voltage_upper</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_width_negative" href="#Rigol1000z.commands.MeasurementStatisticItem.get_width_negative">get_width_negative</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.get_width_positive" href="#Rigol1000z.commands.MeasurementStatisticItem.get_width_positive">get_width_positive</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_area" href="#Rigol1000z.commands.MeasurementStatisticItem.set_area">set_area</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_duty_negative" href="#Rigol1000z.commands.MeasurementStatisticItem.set_duty_negative">set_duty_negative</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_duty_positive" href="#Rigol1000z.commands.MeasurementStatisticItem.set_duty_positive">set_duty_positive</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_edges_negative" href="#Rigol1000z.commands.MeasurementStatisticItem.set_edges_negative">set_edges_negative</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_edges_positive" href="#Rigol1000z.commands.MeasurementStatisticItem.set_edges_positive">set_edges_positive</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_fall_delay" href="#Rigol1000z.commands.MeasurementStatisticItem.set_fall_delay">set_fall_delay</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_fall_phase" href="#Rigol1000z.commands.MeasurementStatisticItem.set_fall_phase">set_fall_phase</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_fall_time" href="#Rigol1000z.commands.MeasurementStatisticItem.set_fall_time">set_fall_time</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_frequency" href="#Rigol1000z.commands.MeasurementStatisticItem.set_frequency">set_frequency</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_period" href="#Rigol1000z.commands.MeasurementStatisticItem.set_period">set_period</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_period_area" href="#Rigol1000z.commands.MeasurementStatisticItem.set_period_area">set_period_area</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_preshoot" href="#Rigol1000z.commands.MeasurementStatisticItem.set_preshoot">set_preshoot</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_pules_negative" href="#Rigol1000z.commands.MeasurementStatisticItem.set_pules_negative">set_pules_negative</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_pules_positive" href="#Rigol1000z.commands.MeasurementStatisticItem.set_pules_positive">set_pules_positive</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_rise_delay" href="#Rigol1000z.commands.MeasurementStatisticItem.set_rise_delay">set_rise_delay</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_rise_phase" href="#Rigol1000z.commands.MeasurementStatisticItem.set_rise_phase">set_rise_phase</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_rise_time" href="#Rigol1000z.commands.MeasurementStatisticItem.set_rise_time">set_rise_time</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_slew_rate_negative" href="#Rigol1000z.commands.MeasurementStatisticItem.set_slew_rate_negative">set_slew_rate_negative</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_slew_rate_positive" href="#Rigol1000z.commands.MeasurementStatisticItem.set_slew_rate_positive">set_slew_rate_positive</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_time_voltage_max" href="#Rigol1000z.commands.MeasurementStatisticItem.set_time_voltage_max">set_time_voltage_max</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_time_voltage_min" href="#Rigol1000z.commands.MeasurementStatisticItem.set_time_voltage_min">set_time_voltage_min</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_variance" href="#Rigol1000z.commands.MeasurementStatisticItem.set_variance">set_variance</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_amp" href="#Rigol1000z.commands.MeasurementStatisticItem.set_voltage_amp">set_voltage_amp</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_average" href="#Rigol1000z.commands.MeasurementStatisticItem.set_voltage_average">set_voltage_average</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_base" href="#Rigol1000z.commands.MeasurementStatisticItem.set_voltage_base">set_voltage_base</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_lower" href="#Rigol1000z.commands.MeasurementStatisticItem.set_voltage_lower">set_voltage_lower</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_max" href="#Rigol1000z.commands.MeasurementStatisticItem.set_voltage_max">set_voltage_max</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_mid" href="#Rigol1000z.commands.MeasurementStatisticItem.set_voltage_mid">set_voltage_mid</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_min" href="#Rigol1000z.commands.MeasurementStatisticItem.set_voltage_min">set_voltage_min</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_overshoot" href="#Rigol1000z.commands.MeasurementStatisticItem.set_voltage_overshoot">set_voltage_overshoot</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_peak_to_peak" href="#Rigol1000z.commands.MeasurementStatisticItem.set_voltage_peak_to_peak">set_voltage_peak_to_peak</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_rms" href="#Rigol1000z.commands.MeasurementStatisticItem.set_voltage_rms">set_voltage_rms</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_rms_period" href="#Rigol1000z.commands.MeasurementStatisticItem.set_voltage_rms_period">set_voltage_rms_period</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_top" href="#Rigol1000z.commands.MeasurementStatisticItem.set_voltage_top">set_voltage_top</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_voltage_upper" href="#Rigol1000z.commands.MeasurementStatisticItem.set_voltage_upper">set_voltage_upper</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_width_negative" href="#Rigol1000z.commands.MeasurementStatisticItem.set_width_negative">set_width_negative</a></code></li>
<li><code><a title="Rigol1000z.commands.MeasurementStatisticItem.set_width_positive" href="#Rigol1000z.commands.MeasurementStatisticItem.set_width_positive">set_width_positive</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.PreambleContext" href="#Rigol1000z.commands.PreambleContext">PreambleContext</a></code></h4>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.Reference" href="#Rigol1000z.commands.Reference">Reference</a></code></h4>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.Source" href="#Rigol1000z.commands.Source">Source</a></code></h4>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.Storage" href="#Rigol1000z.commands.Storage">Storage</a></code></h4>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.System" href="#Rigol1000z.commands.System">System</a></code></h4>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.Timebase" href="#Rigol1000z.commands.Timebase">Timebase</a></code></h4>
<ul class="">
<li><code><a title="Rigol1000z.commands.Timebase.mode" href="#Rigol1000z.commands.Timebase.mode">mode</a></code></li>
<li><code><a title="Rigol1000z.commands.Timebase.offset" href="#Rigol1000z.commands.Timebase.offset">offset</a></code></li>
<li><code><a title="Rigol1000z.commands.Timebase.scale" href="#Rigol1000z.commands.Timebase.scale">scale</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.TimebaseDelay" href="#Rigol1000z.commands.TimebaseDelay">TimebaseDelay</a></code></h4>
<ul class="">
<li><code><a title="Rigol1000z.commands.TimebaseDelay.enabled" href="#Rigol1000z.commands.TimebaseDelay.enabled">enabled</a></code></li>
<li><code><a title="Rigol1000z.commands.TimebaseDelay.offset" href="#Rigol1000z.commands.TimebaseDelay.offset">offset</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.Trace" href="#Rigol1000z.commands.Trace">Trace</a></code></h4>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.Trigger" href="#Rigol1000z.commands.Trigger">Trigger</a></code></h4>
<ul class="">
<li><code><a title="Rigol1000z.commands.Trigger.trigger_holdoff_s" href="#Rigol1000z.commands.Trigger.trigger_holdoff_s">trigger_holdoff_s</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.TriggerEdge" href="#Rigol1000z.commands.TriggerEdge">TriggerEdge</a></code></h4>
<ul class="">
<li><code><a title="Rigol1000z.commands.TriggerEdge.trigger_level_v" href="#Rigol1000z.commands.TriggerEdge.trigger_level_v">trigger_level_v</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Rigol1000z.commands.Waveform" href="#Rigol1000z.commands.Waveform">Waveform</a></code></h4>
<ul class="two-column">
<li><code><a title="Rigol1000z.commands.Waveform.data_premable" href="#Rigol1000z.commands.Waveform.data_premable">data_premable</a></code></li>
<li><code><a title="Rigol1000z.commands.Waveform.mode" href="#Rigol1000z.commands.Waveform.mode">mode</a></code></li>
<li><code><a title="Rigol1000z.commands.Waveform.read_end_point" href="#Rigol1000z.commands.Waveform.read_end_point">read_end_point</a></code></li>
<li><code><a title="Rigol1000z.commands.Waveform.read_format" href="#Rigol1000z.commands.Waveform.read_format">read_format</a></code></li>
<li><code><a title="Rigol1000z.commands.Waveform.read_start_point" href="#Rigol1000z.commands.Waveform.read_start_point">read_start_point</a></code></li>
<li><code><a title="Rigol1000z.commands.Waveform.source" href="#Rigol1000z.commands.Waveform.source">source</a></code></li>
<li><code><a title="Rigol1000z.commands.Waveform.x_increment" href="#Rigol1000z.commands.Waveform.x_increment">x_increment</a></code></li>
<li><code><a title="Rigol1000z.commands.Waveform.x_origin" href="#Rigol1000z.commands.Waveform.x_origin">x_origin</a></code></li>
<li><code><a title="Rigol1000z.commands.Waveform.x_reference" href="#Rigol1000z.commands.Waveform.x_reference">x_reference</a></code></li>
<li><code><a title="Rigol1000z.commands.Waveform.y_increment" href="#Rigol1000z.commands.Waveform.y_increment">y_increment</a></code></li>
<li><code><a title="Rigol1000z.commands.Waveform.y_origin" href="#Rigol1000z.commands.Waveform.y_origin">y_origin</a></code></li>
<li><code><a title="Rigol1000z.commands.Waveform.y_reference" href="#Rigol1000z.commands.Waveform.y_reference">y_reference</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>